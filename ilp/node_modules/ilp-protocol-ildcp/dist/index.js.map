{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import * as IlpPacket from 'ilp-packet'\nimport { Predictor, Reader, Writer, WriterInterface } from 'oer-utils'\nimport debug from 'debug'\n\nconst log = debug('ilp-protocol-ildcp')\n\nconst ILDCP_DESTINATION = 'peer.config' as IlpPacket.IlpAddress\nconst PEER_PROTOCOL_FULFILLMENT = Buffer.alloc(32)\nconst PEER_PROTOCOL_CONDITION = Buffer.from(\n  'Zmh6rfhivXdsj8GLjp+OIAiXFIVu4jOzkCpZHQ1fKSU=',\n  'base64'\n)\nconst PEER_PROTOCOL_EXPIRY_DURATION = 60000\n\nexport interface IldcpRequest {\n  expiresAt?: Date\n  data?: Buffer\n}\n\nexport interface IldcpResponse {\n  clientAddress: string\n  assetScale: number\n  assetCode: string\n}\n\nconst deserializeIldcpRequest = (request: Buffer): IldcpRequest => {\n  const ilp = IlpPacket.deserializeIlpPrepare(request)\n\n  if (ilp.destination !== ILDCP_DESTINATION) {\n    throw new TypeError('packet is not an IL-DCP request.')\n  }\n\n  if (!PEER_PROTOCOL_CONDITION.equals(ilp.executionCondition)) {\n    throw new Error('packet does not contain correct condition for a peer protocol request.')\n  }\n\n  if (Date.now() > Number(ilp.expiresAt)) {\n    throw new Error('IL-DCP request packet is expired.')\n  }\n\n  return {\n    expiresAt: ilp.expiresAt,\n    data: ilp.data,\n  }\n}\n\nconst serializeIldcpRequest = (request: IldcpRequest): Buffer => {\n  return IlpPacket.serializeIlpPrepare({\n    amount: '0',\n    destination: ILDCP_DESTINATION,\n    executionCondition: PEER_PROTOCOL_CONDITION,\n    expiresAt: request.expiresAt || new Date(Date.now() + PEER_PROTOCOL_EXPIRY_DURATION),\n    data: request.data || Buffer.alloc(0),\n  })\n}\n\nconst deserializeIldcpResponse = (\n  response: Buffer\n): IldcpResponse & {\n  clientAddress: IlpPacket.IlpAddress\n  assetScale: AssetScale\n} => {\n  const { fulfillment, data } = IlpPacket.deserializeIlpFulfill(response)\n\n  if (!PEER_PROTOCOL_FULFILLMENT.equals(fulfillment)) {\n    throw new Error('IL-DCP response does not contain the expected fulfillment.')\n  }\n\n  const reader = Reader.from(data)\n\n  const clientAddress = reader.readVarOctetString().toString('ascii')\n  if (!IlpPacket.isValidIlpAddress(clientAddress)) {\n    throw new Error('Invalid ILP address')\n  }\n\n  const assetScale = reader.readUInt8Number() as AssetScale\n  const assetCode = reader.readVarOctetString().toString('utf8')\n\n  return { clientAddress, assetScale, assetCode }\n}\n\nconst writeIldcpResponse = (\n  writer: WriterInterface,\n  clientAddress: Buffer,\n  assetScale: number,\n  assetCode: Buffer\n): void => {\n  writer.writeVarOctetString(clientAddress)\n  writer.writeUInt8(assetScale)\n  writer.writeVarOctetString(assetCode)\n}\n\nconst serializeIldcpResponse = (response: IldcpResponse): Buffer => {\n  const clientAddress = Buffer.from(response.clientAddress, 'ascii')\n  const assetCode = Buffer.from(response.assetCode, 'utf8')\n\n  const predictor = new Predictor()\n  writeIldcpResponse(predictor, clientAddress, response.assetScale, assetCode)\n\n  const writer = new Writer(predictor.length)\n  writeIldcpResponse(writer, clientAddress, response.assetScale, assetCode)\n\n  return IlpPacket.serializeIlpFulfill({\n    fulfillment: PEER_PROTOCOL_FULFILLMENT,\n    data: writer.getBuffer(),\n  })\n}\n\nconst fetch = async (\n  sendData: (data: Buffer) => Promise<Buffer>,\n  request?: IldcpRequest\n): Promise<IldcpResponse> => {\n  const data = await sendData(serializeIldcpRequest(request || {}))\n\n  if (data[0] === IlpPacket.IlpPacketType.Reject) {\n    const { triggeredBy, message } = IlpPacket.deserializeIlpReject(data)\n    log('IL-DCP request rejected. triggeredBy=%s errorMessage=%s', triggeredBy, message)\n    throw new Error('IL-DCP failed: ' + message)\n  } else if (data[0] !== IlpPacket.IlpPacketType.Fulfill) {\n    log('invalid response type. type=%s', data[0])\n    throw new Error('IL-DCP error, unable to retrieve client configuration.')\n  }\n\n  const { clientAddress, assetScale, assetCode } = deserializeIldcpResponse(data)\n\n  log(\n    'received client info. clientAddress=%s assetScale=%s assetCode=%s',\n    clientAddress,\n    assetScale,\n    assetCode\n  )\n\n  return { clientAddress, assetScale, assetCode }\n}\n\nexport interface ServeSettings {\n  requestPacket: Buffer\n  handler: (request: IldcpRequest) => Promise<IldcpResponse>\n  serverAddress: string\n}\n\nconst isObject = (o: unknown): o is Record<string, unknown> => typeof o === 'object' && o !== null\n\nconst serve = async ({ requestPacket, handler, serverAddress }: ServeSettings): Promise<Buffer> => {\n  try {\n    // Parse the request packet just to make sure it's valid\n    deserializeIldcpRequest(requestPacket)\n\n    // In the future, the request packet may contain some parameters. We will pass\n    // these to the handler as an object, the handler will then return the\n    // response as a JavaScript object.\n    const info = await handler({})\n\n    return serializeIldcpResponse(info)\n  } catch (err) {\n    log('error while handling ildcp request. error=%s', err)\n\n    return IlpPacket.serializeIlpReject({\n      code: 'F00',\n      message:\n        isObject(err) && 'message' in err && typeof err.message === 'string'\n          ? err.message\n          : 'unexpected error.',\n      triggeredBy: serverAddress,\n      data: Buffer.alloc(0),\n    })\n  }\n}\n\ndeclare class Tag<N extends string> {\n  protected __nominal: N\n}\n\ntype Brand<T, N extends string> = T & Tag<N>\n\ntype AssetScale = Brand<number, 'AssetScale'>\n\nconst isValidAssetScale = (o: unknown): o is AssetScale =>\n  typeof o === 'number' && o >= 0 && o <= 255 && Number.isInteger(o)\n\nexport {\n  deserializeIldcpRequest,\n  serializeIldcpRequest,\n  deserializeIldcpResponse,\n  serializeIldcpResponse,\n  fetch,\n  serve,\n  AssetScale,\n  isValidAssetScale,\n}\n"]}