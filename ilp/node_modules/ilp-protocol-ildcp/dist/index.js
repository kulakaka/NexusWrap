"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidAssetScale = exports.serve = exports.fetch = exports.serializeIldcpResponse = exports.deserializeIldcpResponse = exports.serializeIldcpRequest = exports.deserializeIldcpRequest = void 0;
const IlpPacket = __importStar(require("ilp-packet"));
const oer_utils_1 = require("oer-utils");
const debug_1 = __importDefault(require("debug"));
const log = (0, debug_1.default)('ilp-protocol-ildcp');
const ILDCP_DESTINATION = 'peer.config';
const PEER_PROTOCOL_FULFILLMENT = Buffer.alloc(32);
const PEER_PROTOCOL_CONDITION = Buffer.from('Zmh6rfhivXdsj8GLjp+OIAiXFIVu4jOzkCpZHQ1fKSU=', 'base64');
const PEER_PROTOCOL_EXPIRY_DURATION = 60000;
const deserializeIldcpRequest = (request) => {
    const ilp = IlpPacket.deserializeIlpPrepare(request);
    if (ilp.destination !== ILDCP_DESTINATION) {
        throw new TypeError('packet is not an IL-DCP request.');
    }
    if (!PEER_PROTOCOL_CONDITION.equals(ilp.executionCondition)) {
        throw new Error('packet does not contain correct condition for a peer protocol request.');
    }
    if (Date.now() > Number(ilp.expiresAt)) {
        throw new Error('IL-DCP request packet is expired.');
    }
    return {
        expiresAt: ilp.expiresAt,
        data: ilp.data,
    };
};
exports.deserializeIldcpRequest = deserializeIldcpRequest;
const serializeIldcpRequest = (request) => {
    return IlpPacket.serializeIlpPrepare({
        amount: '0',
        destination: ILDCP_DESTINATION,
        executionCondition: PEER_PROTOCOL_CONDITION,
        expiresAt: request.expiresAt || new Date(Date.now() + PEER_PROTOCOL_EXPIRY_DURATION),
        data: request.data || Buffer.alloc(0),
    });
};
exports.serializeIldcpRequest = serializeIldcpRequest;
const deserializeIldcpResponse = (response) => {
    const { fulfillment, data } = IlpPacket.deserializeIlpFulfill(response);
    if (!PEER_PROTOCOL_FULFILLMENT.equals(fulfillment)) {
        throw new Error('IL-DCP response does not contain the expected fulfillment.');
    }
    const reader = oer_utils_1.Reader.from(data);
    const clientAddress = reader.readVarOctetString().toString('ascii');
    if (!IlpPacket.isValidIlpAddress(clientAddress)) {
        throw new Error('Invalid ILP address');
    }
    const assetScale = reader.readUInt8Number();
    const assetCode = reader.readVarOctetString().toString('utf8');
    return { clientAddress, assetScale, assetCode };
};
exports.deserializeIldcpResponse = deserializeIldcpResponse;
const writeIldcpResponse = (writer, clientAddress, assetScale, assetCode) => {
    writer.writeVarOctetString(clientAddress);
    writer.writeUInt8(assetScale);
    writer.writeVarOctetString(assetCode);
};
const serializeIldcpResponse = (response) => {
    const clientAddress = Buffer.from(response.clientAddress, 'ascii');
    const assetCode = Buffer.from(response.assetCode, 'utf8');
    const predictor = new oer_utils_1.Predictor();
    writeIldcpResponse(predictor, clientAddress, response.assetScale, assetCode);
    const writer = new oer_utils_1.Writer(predictor.length);
    writeIldcpResponse(writer, clientAddress, response.assetScale, assetCode);
    return IlpPacket.serializeIlpFulfill({
        fulfillment: PEER_PROTOCOL_FULFILLMENT,
        data: writer.getBuffer(),
    });
};
exports.serializeIldcpResponse = serializeIldcpResponse;
const fetch = async (sendData, request) => {
    const data = await sendData(serializeIldcpRequest(request || {}));
    if (data[0] === IlpPacket.IlpPacketType.Reject) {
        const { triggeredBy, message } = IlpPacket.deserializeIlpReject(data);
        log('IL-DCP request rejected. triggeredBy=%s errorMessage=%s', triggeredBy, message);
        throw new Error('IL-DCP failed: ' + message);
    }
    else if (data[0] !== IlpPacket.IlpPacketType.Fulfill) {
        log('invalid response type. type=%s', data[0]);
        throw new Error('IL-DCP error, unable to retrieve client configuration.');
    }
    const { clientAddress, assetScale, assetCode } = deserializeIldcpResponse(data);
    log('received client info. clientAddress=%s assetScale=%s assetCode=%s', clientAddress, assetScale, assetCode);
    return { clientAddress, assetScale, assetCode };
};
exports.fetch = fetch;
const isObject = (o) => typeof o === 'object' && o !== null;
const serve = async ({ requestPacket, handler, serverAddress }) => {
    try {
        deserializeIldcpRequest(requestPacket);
        const info = await handler({});
        return serializeIldcpResponse(info);
    }
    catch (err) {
        log('error while handling ildcp request. error=%s', err);
        return IlpPacket.serializeIlpReject({
            code: 'F00',
            message: isObject(err) && 'message' in err && typeof err.message === 'string'
                ? err.message
                : 'unexpected error.',
            triggeredBy: serverAddress,
            data: Buffer.alloc(0),
        });
    }
};
exports.serve = serve;
const isValidAssetScale = (o) => typeof o === 'number' && o >= 0 && o <= 255 && Number.isInteger(o);
exports.isValidAssetScale = isValidAssetScale;
//# sourceMappingURL=index.js.map