{"version":3,"file":"util.js","sourceRoot":"","sources":["../../src/lib/util.ts"],"names":[],"mappings":"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","sourcesContent":["import Long from 'long'\n\n// How many bytes are safe to decode as a JS number\n// MAX_SAFE_INTEGER = 2^53 - 1\n// 53 div 8 -> 6 bytes\nexport const MAX_SAFE_BYTES = 6\n\nexport type SafeByteLength = 1 | 2 | 3 | 4 | 5 | 6\n\nexport const isSafeLength = (length: number): length is SafeByteLength =>\n  isInteger(length) && length >= 1 && length <= MAX_SAFE_BYTES\n\nconst INTEGER_REGEX = /^-?[0-9]+$/\nexport function isInteger(value: unknown): boolean {\n  if (typeof value === 'number') {\n    return isFinite(value) && Math.floor(value) === value\n  } else if (typeof value === 'string') {\n    return !!INTEGER_REGEX.exec(value)\n  } else {\n    return Long.isLong(value)\n  }\n}\n\nexport const isLong = Long.isLong\n\nexport function longFromValue(value: Long | string | number, unsigned: boolean): Long {\n  if (typeof value === 'number') {\n    if (unsigned && value < 0) {\n      throw new Error('UInt must be positive')\n    }\n    return Long.fromNumber(value, unsigned)\n  }\n\n  if (isLong(value)) {\n    if (value.unsigned !== unsigned) {\n      if (unsigned) throw new Error('Expected unsigned Long')\n      else throw new Error('Expected signed Long')\n    }\n    return value\n  }\n\n  if (unsigned && value[0] === '-') {\n    throw new Error('UInt must be positive')\n  }\n  return Long.fromString(value, unsigned)\n}\n\nexport function bufferToLong(buffer: Buffer, unsigned: boolean): Long {\n  if (buffer.length > 8) {\n    throw new Error((unsigned ? 'UInt' : 'Int') + ' of length ' + buffer.length + ' is too large')\n  }\n\n  if (unsigned) {\n    return buffer.reduce((sum, value) => sum.shiftLeft(8).add(value), Long.UZERO)\n  } else {\n    return buffer.reduce(\n      (sum, value, i) => sum.multiply(256).add(i === 0 && 0x80 <= value ? value - 0x100 : value),\n      Long.ZERO\n    )\n  }\n}\n\n/**\n * @param value is unsigned\n * @param length\n */\nexport function longToBuffer(value: Long, length: number): Buffer {\n  return Buffer.from(value.toBytesBE().slice(8 - length))\n}\n\nconst LONG_VAR_UINT_SIZES: LongSizeRange[] = new Array(8)\nconst LONG_VAR_INT_SIZES: LongSizeRange[] = new Array(8)\n\nfor (let i = 0; i < 8; i++) {\n  LONG_VAR_UINT_SIZES[i] = {\n    min: Long.UZERO,\n    max: Long.MAX_UNSIGNED_VALUE.shiftRightUnsigned(64 - 8 * (i + 1)),\n    bytes: i + 1,\n  }\n  LONG_VAR_INT_SIZES[i] = {\n    min: Long.MIN_VALUE.shiftRight(64 - 8 * (i + 1)),\n    max: Long.MAX_VALUE.shiftRight(64 - 8 * (i + 1)),\n    bytes: i + 1,\n  }\n}\n\nconst VAR_UINT_SIZES: NumberSizeRange[] = makeNumberRanges(LONG_VAR_UINT_SIZES)\nconst VAR_INT_SIZES: NumberSizeRange[] = makeNumberRanges(LONG_VAR_INT_SIZES)\n\n// Returns the minimum number of bytes required to encode the value.\nexport function getLongUIntBufferSize(value: Long): number {\n  for (let i = 0; i < LONG_VAR_UINT_SIZES.length; i++) {\n    const item = LONG_VAR_UINT_SIZES[i]\n    if (value.lessThanOrEqual(item.max)) {\n      // Fast path: no extra work converting a Long to a String.\n      return item.bytes\n    }\n  }\n  throw new Error('unreachable')\n}\n\nexport function getUIntBufferSize(value: number): number {\n  for (let i = 0; i < VAR_UINT_SIZES.length; i++) {\n    const item = VAR_UINT_SIZES[i]\n    if (value <= item.max) return item.bytes\n  }\n  return computeLongBufferSize(Long.fromNumber(value, true))\n}\n\n// Returns the minimum number of bytes required to encode the value.\nexport function getLongIntBufferSize(value: Long): number {\n  for (let i = 0; i < LONG_VAR_INT_SIZES.length; i++) {\n    const item = LONG_VAR_INT_SIZES[i]\n    if (value.greaterThanOrEqual(item.min) && value.lessThanOrEqual(item.max)) {\n      // Fast path: no extra work converting a Long to a String.\n      return item.bytes\n    }\n  }\n  throw new Error('unreachable')\n}\n\nexport function getIntBufferSize(value: number): number {\n  for (let i = 0; i < VAR_INT_SIZES.length; i++) {\n    const item = VAR_INT_SIZES[i]\n    if (value >= item.min && value <= item.max) return item.bytes\n  }\n  return computeLongBufferSize(Long.fromNumber(value, false))\n}\n\nfunction computeLongBufferSize(value: Long): number {\n  return Math.ceil(value.toString(16).length / 2)\n}\n\ninterface LongSizeRange {\n  // UInt ranges don't use min.\n  min: Long\n  max: Long\n  bytes: number\n}\n\ninterface NumberSizeRange {\n  // UInt ranges don't use min.\n  min: number\n  max: number\n  bytes: number\n}\n\nfunction makeNumberRanges(ranges: LongSizeRange[]): NumberSizeRange[] {\n  return ranges\n    .filter((range) => range.bytes <= MAX_SAFE_BYTES)\n    .map((range) => ({\n      min: range.min && range.min.toNumber(),\n      max: range.max.toNumber(),\n      bytes: range.bytes,\n    }))\n}\n"]}