"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("./util");
class Writer {
    constructor(value) {
        if (Buffer.isBuffer(value)) {
            this.buffer = value;
            this.strict = true;
        }
        else {
            this.buffer = Buffer.alloc(value || 0);
            this.strict = typeof value === 'number';
        }
        this._offset = 0;
    }
    get length() {
        return this._offset;
    }
    writeUInt(_value, length) {
        if (!(0, util_1.isInteger)(_value)) {
            throw new Error('UInt must be an integer');
        }
        else if (!(0, util_1.isInteger)(length)) {
            throw new Error('Length must be an integer');
        }
        else if (typeof _value === 'number' && _value > Writer.MAX_SAFE_INTEGER) {
            throw new Error('UInt is larger than safe JavaScript range (try using Longs instead)');
        }
        else if (length <= 0) {
            throw new Error('UInt length must be greater than zero');
        }
        else if ((0, util_1.isLong)(_value) && !_value.unsigned) {
            throw new Error('Expected unsigned Long');
        }
        if ((0, util_1.isSafeLength)(length)) {
            const value = Number(_value);
            if (value < 0) {
                throw new Error('UInt must be positive');
            }
            else if (value > Writer.UINT_RANGES[length]) {
                throw new Error(`UInt ${_value} does not fit in ${length} bytes`);
            }
            const offset = this.advance(length);
            this.buffer.writeUIntBE(value, offset, length);
        }
        else {
            const value = (0, util_1.longFromValue)(_value, true);
            if (length < (0, util_1.getLongUIntBufferSize)(value)) {
                throw new Error(`UInt ${value} does not fit in ${length} bytes`);
            }
            this.write((0, util_1.longToBuffer)(value, length));
        }
    }
    writeInt(_value, length) {
        if (!(0, util_1.isInteger)(_value)) {
            throw new Error('Int must be an integer');
        }
        else if (!(0, util_1.isInteger)(length)) {
            throw new Error('Length must be an integer');
        }
        else if (length <= 0) {
            throw new Error('Int length must be greater than zero');
        }
        else if (typeof _value === 'number' && _value > Writer.MAX_SAFE_INTEGER) {
            throw new Error('Int is larger than safe JavaScript range (try using Longs instead)');
        }
        else if (typeof _value === 'number' && _value < Writer.MIN_SAFE_INTEGER) {
            throw new Error('Int is smaller than safe JavaScript range (try using Longs instead)');
        }
        else if ((0, util_1.isLong)(_value) && _value.unsigned) {
            throw new Error('Expected signed Long');
        }
        if ((0, util_1.isSafeLength)(length)) {
            const value = Number(_value);
            if (value < Writer.INT_RANGES[length][0] || value > Writer.INT_RANGES[length][1]) {
                throw new Error('Int ' + _value + ' does not fit in ' + length + ' bytes');
            }
            const offset = this.advance(length);
            this.buffer.writeIntBE(value, offset, length);
        }
        else {
            const value = (0, util_1.longFromValue)(_value, false);
            if (length < (0, util_1.getLongIntBufferSize)(value)) {
                throw new Error('Int ' + value + ' does not fit in ' + length + ' bytes');
            }
            this.write((0, util_1.longToBuffer)(value, length));
        }
    }
    writeVarUInt(_value) {
        if (Buffer.isBuffer(_value)) {
            this.writeVarOctetString(_value);
            return;
        }
        else if (!(0, util_1.isInteger)(_value)) {
            throw new Error('UInt must be an integer');
        }
        let value;
        let lengthOfValue;
        if (typeof _value === 'number') {
            value = _value;
            lengthOfValue = (0, util_1.getUIntBufferSize)(value);
        }
        else {
            value = (0, util_1.longFromValue)(_value, true);
            lengthOfValue = (0, util_1.getLongUIntBufferSize)(value);
        }
        this.createVarOctetString(lengthOfValue).writeUInt(value, lengthOfValue);
    }
    writeVarInt(_value) {
        if (Buffer.isBuffer(_value)) {
            this.writeVarOctetString(_value);
            return;
        }
        else if (!(0, util_1.isInteger)(_value)) {
            throw new Error('Int must be an integer');
        }
        else if (typeof _value === 'number' && _value > Writer.MAX_SAFE_INTEGER) {
            throw new Error('Int is larger than safe JavaScript range');
        }
        else if (typeof _value === 'number' && _value < Writer.MIN_SAFE_INTEGER) {
            throw new Error('Int is smaller than safe JavaScript range');
        }
        let value;
        let lengthOfValue;
        if (typeof _value === 'number') {
            value = _value;
            lengthOfValue = (0, util_1.getIntBufferSize)(value);
        }
        else {
            value = (0, util_1.longFromValue)(_value, false);
            lengthOfValue = (0, util_1.getLongIntBufferSize)(value);
        }
        this.createVarOctetString(lengthOfValue).writeInt(value, lengthOfValue);
    }
    writeOctetString(buffer, length) {
        if (buffer.length !== length) {
            throw new Error('Incorrect length for octet string (actual: ' +
                buffer.length +
                ', expected: ' +
                length +
                ')');
        }
        this.write(buffer);
    }
    writeVarOctetString(buffer) {
        if (Buffer.isBuffer(buffer)) {
            this._writeLengthPrefix(buffer.length);
            this.write(buffer);
        }
        else {
            throw new TypeError('Expects a buffer');
        }
    }
    createVarOctetString(length) {
        if (length < 0) {
            throw new Error('length must be non-negative');
        }
        this._writeLengthPrefix(length);
        const offset = this.advance(length);
        const slice = this.buffer.slice(offset, offset + length);
        return new Writer(slice);
    }
    _writeLengthPrefix(length) {
        const MSB = 0x80;
        if (length <= 127) {
            this.writeUInt8(length);
        }
        else {
            const lengthOfLength = (0, util_1.getUIntBufferSize)(length);
            this.writeUInt8(MSB | lengthOfLength);
            this.writeUInt(length, lengthOfLength);
        }
    }
    write(buffer) {
        const offset = this.advance(buffer.length);
        buffer.copy(this.buffer, offset);
    }
    getBuffer() {
        return this.buffer.slice(0, this._offset);
    }
    advance(advanceBy) {
        const srcOffset = this._offset;
        const minCapacity = srcOffset + advanceBy;
        if (minCapacity <= this.buffer.length) {
            this._offset += advanceBy;
            return srcOffset;
        }
        if (this.strict) {
            throw new Error('writer cannot exceed capacity');
        }
        let capacity = this.buffer.length || Writer.MIN_BUFFER_SIZE;
        while (capacity < minCapacity)
            capacity *= 2;
        const newBuffer = Buffer.alloc(capacity);
        if (this.buffer.length) {
            this.buffer.copy(newBuffer);
        }
        this.buffer = newBuffer;
        this._offset += advanceBy;
        return srcOffset;
    }
}
Writer.MAX_SAFE_INTEGER = 0x1fffffffffffff;
Writer.MIN_SAFE_INTEGER = -0x1fffffffffffff;
Writer.MIN_BUFFER_SIZE = 32;
Writer.UINT_RANGES = {
    1: 0xff,
    2: 0xffff,
    3: 0xffffff,
    4: 0xffffffff,
    5: 0xffffffffff,
    6: 0xffffffffffff,
};
Writer.INT_RANGES = {
    1: [-0x80, 0x7f],
    2: [-0x8000, 0x7fff],
    3: [-0x800000, 0x7fffff],
    4: [-0x80000000, 0x7fffffff],
    5: [-0x8000000000, 0x7fffffffff],
    6: [-0x800000000000, 0x7fffffffffff],
};
;
[8, 16, 32, 64].forEach((bits) => {
    Writer.prototype[`writeUInt${bits}`] = function (value) {
        this.writeUInt(value, bits / 8);
    };
    Writer.prototype[`writeInt${bits}`] = function (value) {
        this.writeInt(value, bits / 8);
    };
});
exports.default = Writer;
//# sourceMappingURL=writer.js.map