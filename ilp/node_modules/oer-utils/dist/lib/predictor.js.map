{"version":3,"file":"predictor.js","sourceRoot":"","sources":["../../src/lib/predictor.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  isInteger,\n  longFromValue,\n  getUIntBufferSize,\n  getIntBufferSize,\n  getLongUIntBufferSize,\n  getLongIntBufferSize,\n} from './util'\nimport Long from 'long'\nimport { WriterInterface } from './writer'\n\ntype LongValue = Long | number | string\n\n/**\n * Writable stream which tracks the amount of data written.\n *\n * This class acts as a writable stream, but only does the minimum amount of\n * work necessary to count/predict the output size.\n */\nclass Predictor implements WriterInterface {\n  private size: number\n\n  constructor() {\n    this.size = 0\n  }\n\n  get length(): number {\n    return this.size\n  }\n\n  /**\n   * Add the size of a fixed-length unsigned integer to the predicted size.\n   */\n  writeUInt(value: LongValue, length: number) {\n    this.size += length\n  }\n\n  /**\n   * Add the size of a fixed-length integer to the predicted size.\n   */\n  writeInt(value: LongValue, length: number) {\n    this.size += length\n  }\n\n  /**\n   * Calculate the size of a variable-length unsigned integer.\n   */\n  writeVarUInt(_value: LongValue) {\n    if (!isInteger(_value)) {\n      throw new Error('UInt must be an integer')\n    }\n\n    let lengthOfValue\n    if (typeof _value === 'number') {\n      if (_value < 0) {\n        throw new Error('UInt must be positive')\n      }\n      // Fast path for numbers.\n      lengthOfValue = getUIntBufferSize(_value)\n    } else {\n      const value = longFromValue(_value, true)\n      lengthOfValue = getLongUIntBufferSize(value)\n    }\n\n    this.skipVarOctetString(lengthOfValue)\n  }\n\n  /**\n   * Calculate the size of a variable-length integer.\n   */\n  writeVarInt(_value: LongValue) {\n    if (!isInteger(_value)) {\n      throw new Error('UInt must be an integer')\n    }\n\n    let lengthOfValue\n    if (typeof _value === 'number') {\n      lengthOfValue = getIntBufferSize(_value)\n    } else {\n      const value = longFromValue(_value, false)\n      lengthOfValue = getLongIntBufferSize(value)\n    }\n\n    this.skipVarOctetString(lengthOfValue)\n  }\n\n  /**\n   * Skip bytes for a fixed-length octet string.\n   */\n  writeOctetString(buffer: Buffer, length: number) {\n    if (buffer.length !== length) {\n      throw new Error(\n        'Incorrect length for octet string (actual: ' +\n          buffer.length +\n          ', expected: ' +\n          length +\n          ')'\n      )\n    }\n    this.skip(length)\n  }\n\n  /**\n   * Skip bytes for a variable-length octet string.\n   */\n  writeVarOctetString(buffer: Buffer) {\n    this.skipVarOctetString(buffer.length)\n  }\n\n  /**\n   * Skip bytes for a variable-length octet string.\n   */\n  createVarOctetString(length: number): WriterInterface {\n    this.skipVarOctetString(length)\n    return new Predictor()\n  }\n\n  /**\n   * Pretend to write a series of bytes.\n   *\n   * @param {Buffer} Bytes to write.\n   */\n  write(bytes: Buffer) {\n    this.size += bytes.length\n  }\n\n  /**\n   * Add this many bytes to the predicted size.\n   *\n   * @param {Number} Number of bytes to pretend to write.\n   */\n  skip(bytes: number) {\n    this.size += bytes\n  }\n\n  /**\n   * Get the size the buffer would have if this was a real writer.\n   *\n   * @return {Number} Size in bytes.\n   */\n  getSize() {\n    return this.size\n  }\n\n  static measureVarOctetString(length: number): number {\n    // Skip initial byte\n    let total = 1\n\n    // Skip separate length field if there is one\n    if (length > 127) {\n      const lengthOfLength = getUIntBufferSize(length)\n      total += lengthOfLength\n    }\n\n    total += length\n    return total\n  }\n\n  private skipVarOctetString(length: number) {\n    this.skip(Predictor.measureVarOctetString(length))\n  }\n}\n\ninterface Predictor {\n  writeUInt8(value: number): void\n  writeUInt16(value: number): void\n  writeUInt32(value: number): void\n  writeUInt64(value: number): void\n  writeInt8(value: number): void\n  writeInt16(value: number): void\n  writeInt32(value: number): void\n  writeInt64(value: number): void\n}\n\n// Create writeUInt{8,16,32,64} shortcuts\n;([8, 16, 32, 64] as const).forEach((bits) => {\n  Predictor.prototype[`writeUInt${bits}`] = function (value) {\n    return this.writeUInt(value, bits / 8)\n  }\n\n  Predictor.prototype[`writeInt${bits}`] = function (value) {\n    return this.writeUInt(value, bits / 8)\n  }\n})\n\nexport default Predictor\n"]}