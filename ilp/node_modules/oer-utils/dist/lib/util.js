"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIntBufferSize = exports.getLongIntBufferSize = exports.getUIntBufferSize = exports.getLongUIntBufferSize = exports.longToBuffer = exports.bufferToLong = exports.longFromValue = exports.isLong = exports.isInteger = exports.isSafeLength = exports.MAX_SAFE_BYTES = void 0;
const long_1 = __importDefault(require("long"));
exports.MAX_SAFE_BYTES = 6;
const isSafeLength = (length) => isInteger(length) && length >= 1 && length <= exports.MAX_SAFE_BYTES;
exports.isSafeLength = isSafeLength;
const INTEGER_REGEX = /^-?[0-9]+$/;
function isInteger(value) {
    if (typeof value === 'number') {
        return isFinite(value) && Math.floor(value) === value;
    }
    else if (typeof value === 'string') {
        return !!INTEGER_REGEX.exec(value);
    }
    else {
        return long_1.default.isLong(value);
    }
}
exports.isInteger = isInteger;
exports.isLong = long_1.default.isLong;
function longFromValue(value, unsigned) {
    if (typeof value === 'number') {
        if (unsigned && value < 0) {
            throw new Error('UInt must be positive');
        }
        return long_1.default.fromNumber(value, unsigned);
    }
    if ((0, exports.isLong)(value)) {
        if (value.unsigned !== unsigned) {
            if (unsigned)
                throw new Error('Expected unsigned Long');
            else
                throw new Error('Expected signed Long');
        }
        return value;
    }
    if (unsigned && value[0] === '-') {
        throw new Error('UInt must be positive');
    }
    return long_1.default.fromString(value, unsigned);
}
exports.longFromValue = longFromValue;
function bufferToLong(buffer, unsigned) {
    if (buffer.length > 8) {
        throw new Error((unsigned ? 'UInt' : 'Int') + ' of length ' + buffer.length + ' is too large');
    }
    if (unsigned) {
        return buffer.reduce((sum, value) => sum.shiftLeft(8).add(value), long_1.default.UZERO);
    }
    else {
        return buffer.reduce((sum, value, i) => sum.multiply(256).add(i === 0 && 0x80 <= value ? value - 0x100 : value), long_1.default.ZERO);
    }
}
exports.bufferToLong = bufferToLong;
function longToBuffer(value, length) {
    return Buffer.from(value.toBytesBE().slice(8 - length));
}
exports.longToBuffer = longToBuffer;
const LONG_VAR_UINT_SIZES = new Array(8);
const LONG_VAR_INT_SIZES = new Array(8);
for (let i = 0; i < 8; i++) {
    LONG_VAR_UINT_SIZES[i] = {
        min: long_1.default.UZERO,
        max: long_1.default.MAX_UNSIGNED_VALUE.shiftRightUnsigned(64 - 8 * (i + 1)),
        bytes: i + 1,
    };
    LONG_VAR_INT_SIZES[i] = {
        min: long_1.default.MIN_VALUE.shiftRight(64 - 8 * (i + 1)),
        max: long_1.default.MAX_VALUE.shiftRight(64 - 8 * (i + 1)),
        bytes: i + 1,
    };
}
const VAR_UINT_SIZES = makeNumberRanges(LONG_VAR_UINT_SIZES);
const VAR_INT_SIZES = makeNumberRanges(LONG_VAR_INT_SIZES);
function getLongUIntBufferSize(value) {
    for (let i = 0; i < LONG_VAR_UINT_SIZES.length; i++) {
        const item = LONG_VAR_UINT_SIZES[i];
        if (value.lessThanOrEqual(item.max)) {
            return item.bytes;
        }
    }
    throw new Error('unreachable');
}
exports.getLongUIntBufferSize = getLongUIntBufferSize;
function getUIntBufferSize(value) {
    for (let i = 0; i < VAR_UINT_SIZES.length; i++) {
        const item = VAR_UINT_SIZES[i];
        if (value <= item.max)
            return item.bytes;
    }
    return computeLongBufferSize(long_1.default.fromNumber(value, true));
}
exports.getUIntBufferSize = getUIntBufferSize;
function getLongIntBufferSize(value) {
    for (let i = 0; i < LONG_VAR_INT_SIZES.length; i++) {
        const item = LONG_VAR_INT_SIZES[i];
        if (value.greaterThanOrEqual(item.min) && value.lessThanOrEqual(item.max)) {
            return item.bytes;
        }
    }
    throw new Error('unreachable');
}
exports.getLongIntBufferSize = getLongIntBufferSize;
function getIntBufferSize(value) {
    for (let i = 0; i < VAR_INT_SIZES.length; i++) {
        const item = VAR_INT_SIZES[i];
        if (value >= item.min && value <= item.max)
            return item.bytes;
    }
    return computeLongBufferSize(long_1.default.fromNumber(value, false));
}
exports.getIntBufferSize = getIntBufferSize;
function computeLongBufferSize(value) {
    return Math.ceil(value.toString(16).length / 2);
}
function makeNumberRanges(ranges) {
    return ranges
        .filter((range) => range.bytes <= exports.MAX_SAFE_BYTES)
        .map((range) => ({
        min: range.min && range.min.toNumber(),
        max: range.max.toNumber(),
        bytes: range.bytes,
    }));
}
//# sourceMappingURL=util.js.map