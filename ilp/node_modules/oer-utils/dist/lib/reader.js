"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const underflow_error_1 = require("../errors/underflow-error");
const parse_error_1 = require("../errors/parse-error");
const long_1 = __importDefault(require("long"));
const util_1 = require("./util");
class Reader {
    constructor(buffer) {
        this.buffer = buffer;
        this.cursor = 0;
        this.bookmarks = [];
    }
    static from(source) {
        if (Buffer.isBuffer(source)) {
            return new Reader(source);
        }
        else if (source instanceof Reader) {
            return new Reader(source.buffer.slice(source.cursor));
        }
        else {
            throw new Error('Reader must be given a Buffer');
        }
    }
    bookmark() {
        this.bookmarks.push(this.cursor);
    }
    restore() {
        const maybeCursor = this.bookmarks.pop();
        if (typeof maybeCursor === 'undefined') {
            throw new Error('Cannot restore bookmark when no bookmark set');
        }
        this.cursor = maybeCursor;
    }
    ensureAvailable(bytes) {
        if (this.buffer.length < this.cursor + bytes) {
            throw new underflow_error_1.UnderflowError('Tried to read ' +
                bytes +
                ' bytes, but only ' +
                (this.buffer.length - this.cursor) +
                ' bytes available');
        }
    }
    readUIntNumber(length) {
        if (!(0, util_1.isSafeLength)(length)) {
            throw new Error('Length must be a be a positive integer in the range [1,6] to ensure that the parsed integer can be represented as a JavaScript number without sacrificing precision');
        }
        const value = this.buffer.readUIntBE(this.cursor, length);
        this.cursor += length;
        return value;
    }
    readUIntLong(length) {
        const value = this.peekUIntLong(length);
        this.cursor += length;
        return value;
    }
    readUInt(length) {
        if ((0, util_1.isSafeLength)(length)) {
            return String(this.readUIntNumber(length));
        }
        else {
            return this.readUIntLong(length).toString();
        }
    }
    peekUIntNumber(length) {
        if (!(0, util_1.isSafeLength)(length)) {
            throw new Error('Length must be a be a positive integer in the range [1,6] to ensure that the parsed integer can be represented as a JavaScript number without sacrificing precision');
        }
        return this.buffer.readUIntBE(this.cursor, length);
    }
    peekUIntLong(length) {
        if (length === 0) {
            return long_1.default.UZERO;
        }
        else if (length < 0) {
            throw new Error('Tried to read integer with negative length (provided: ' + length + ')');
        }
        else if (length > 8) {
            throw new Error('UInts longer than 8 bytes must be encoded as VarUInts');
        }
        return (0, util_1.bufferToLong)(this.peek(length), true);
    }
    peekUInt(length) {
        if ((0, util_1.isSafeLength)(length)) {
            return String(this.peekUIntNumber(length));
        }
        else {
            return this.peekUIntLong(length).toString();
        }
    }
    skipUInt(length) {
        this.skip(length);
    }
    readIntNumber(length) {
        if (!(0, util_1.isSafeLength)(length)) {
            throw new Error('Length must be a be a positive integer in the range [1,6] to ensure that the parsed integer can be represented as a JavaScript number without sacrificing precision');
        }
        const value = this.buffer.readIntBE(this.cursor, length);
        this.cursor += length;
        return value;
    }
    readIntLong(length) {
        const value = this.peekIntLong(length);
        this.cursor += length;
        return value;
    }
    readInt(length) {
        if ((0, util_1.isSafeLength)(length)) {
            return String(this.readIntNumber(length));
        }
        else {
            return this.readIntLong(length).toString();
        }
    }
    peekIntNumber(length) {
        if (!(0, util_1.isSafeLength)(length)) {
            throw new Error('Length must be a be a positive integer in the range [1,6] to ensure that the parsed integer can be represented as a JavaScript number without sacrificing precision');
        }
        return this.buffer.readIntBE(this.cursor, length);
    }
    peekIntLong(length) {
        if (length === 0) {
            return long_1.default.ZERO;
        }
        else if (length < 0) {
            throw new Error('Tried to read integer with negative length (provided: ' + length + ')');
        }
        else if (length > 8) {
            throw new Error('Ints longer than 8 bytes must be encoded as VarInts');
        }
        return (0, util_1.bufferToLong)(this.peek(length), false);
    }
    peekInt(length) {
        if ((0, util_1.isSafeLength)(length)) {
            return String(this.peekIntNumber(length));
        }
        else {
            return this.peekIntLong(length).toString();
        }
    }
    skipInt(length) {
        this.skip(length);
    }
    readVarUIntNumber() {
        if (!(0, util_1.isSafeLength)(this.buffer[this.cursor])) {
            throw new Error('Length must be a be a positive integer in the range [1,6] to ensure that the parsed integer can be represented as a JavaScript number without sacrificing precision');
        }
        return this.readUIntNumber(this.buffer[this.cursor++]);
    }
    readVarUIntLong() {
        const buffer = this.readVarOctetString();
        if (buffer.length === 0) {
            throw new parse_error_1.ParseError('UInt of length 0 is invalid');
        }
        return (0, util_1.bufferToLong)(buffer, true);
    }
    readVarUInt() {
        return this.readVarUIntLong().toString();
    }
    peekVarUIntNumber() {
        this.bookmark();
        const value = this.readVarUIntNumber();
        this.restore();
        return value;
    }
    peekVarUIntLong() {
        this.bookmark();
        const value = this.readVarUIntLong();
        this.restore();
        return value;
    }
    peekVarUInt() {
        return this.peekVarUIntLong().toString();
    }
    skipVarUInt() {
        this.skipVarOctetString();
    }
    readVarIntNumber() {
        if (!(0, util_1.isSafeLength)(this.buffer[this.cursor])) {
            throw new Error('Length must be a be a positive integer in the range [1,6] to ensure that the parsed integer can be represented as a JavaScript number without sacrificing precision');
        }
        return this.readIntNumber(this.buffer[this.cursor++]);
    }
    readVarIntLong() {
        const buffer = this.readVarOctetString();
        if (buffer.length === 0) {
            throw new parse_error_1.ParseError('Int of length 0 is invalid');
        }
        return (0, util_1.bufferToLong)(buffer, false);
    }
    readVarInt() {
        return this.readVarIntLong().toString();
    }
    peekVarIntNumber() {
        this.bookmark();
        const value = this.readVarIntNumber();
        this.restore();
        return value;
    }
    peekVarIntLong() {
        this.bookmark();
        const value = this.readVarIntLong();
        this.restore();
        return value;
    }
    peekVarInt() {
        return this.peekVarIntLong().toString();
    }
    skipVarInt() {
        this.skipVarOctetString();
    }
    readOctetString(length) {
        return this.read(length);
    }
    peekOctetString(length) {
        return this.peek(length);
    }
    skipOctetString(length) {
        return this.skip(length);
    }
    readLengthPrefix() {
        const length = this.readUInt8Number();
        if (length & Reader.HIGH_BIT) {
            const lengthPrefixLength = length & Reader.LOWER_SEVEN_BITS;
            const actualLength = lengthPrefixLength && this.readUIntNumber(lengthPrefixLength);
            const minLength = Math.max(128, 1 << ((lengthPrefixLength - 1) * 8));
            if (lengthPrefixLength === 0 || actualLength < minLength) {
                throw new parse_error_1.ParseError('Length prefix encoding is not canonical: ' +
                    actualLength +
                    ' encoded in ' +
                    lengthPrefixLength +
                    ' bytes');
            }
            return actualLength;
        }
        return length;
    }
    readVarOctetString() {
        const length = this.readLengthPrefix();
        return this.read(length);
    }
    peekVarOctetString() {
        this.bookmark();
        const value = this.readVarOctetString();
        this.restore();
        return value;
    }
    skipVarOctetString() {
        const length = this.readLengthPrefix();
        this.skip(length);
    }
    read(bytes) {
        this.ensureAvailable(bytes);
        const value = this.buffer.slice(this.cursor, this.cursor + bytes);
        this.cursor += bytes;
        return value;
    }
    peek(bytes) {
        this.ensureAvailable(bytes);
        return this.buffer.slice(this.cursor, this.cursor + bytes);
    }
    skip(bytes) {
        this.ensureAvailable(bytes);
        this.cursor += bytes;
    }
}
Reader.HIGH_BIT = 0x80;
Reader.LOWER_SEVEN_BITS = 0x7f;
;
[8, 16, 32, 64].forEach((bits) => {
    ;
    ['read', 'peek'].forEach((verb) => {
        Reader.prototype[`${verb}UInt${bits}`] = function () {
            return this[`${verb}UInt`](bits / 8);
        };
        Reader.prototype[`${verb}Int${bits}`] = function () {
            return this[`${verb}Int`](bits / 8);
        };
        Reader.prototype[`${verb}UInt${bits}Number`] = function () {
            return this[`${verb}UIntNumber`](bits / 8);
        };
        Reader.prototype[`${verb}Int${bits}Number`] = function () {
            return this[`${verb}IntNumber`](bits / 8);
        };
        Reader.prototype[`${verb}UInt${bits}Long`] = function () {
            return this[`${verb}UIntLong`](bits / 8);
        };
        Reader.prototype[`${verb}Int${bits}Long`] = function () {
            return this[`${verb}IntLong`](bits / 8);
        };
    });
    Reader.prototype[`skipUInt${bits}`] = function () {
        return this[`skipUInt`](bits / 8);
    };
    Reader.prototype[`skipInt${bits}`] = function () {
        return this[`skipInt`](bits / 8);
    };
});
exports.default = Reader;
//# sourceMappingURL=reader.js.map