/// <reference types="node" />
import { Logger } from 'ilp-logger';
import Long from 'long';
import { Duplex } from 'stream';
import { DataQueue } from './util/data-queue';
import { OffsetSorter } from './util/data-offset-sorter';
import { LongValue } from './util/long';
import { IlpPrepare } from 'ilp-packet';
export interface StreamOpts {
    id: number;
    isServer: boolean;
    connectionId: string;
}
export interface SendOpts {
    timeout?: number;
}
export interface ReceiveOpts {
    timeout?: number;
}
export declare class DataAndMoneyStream extends Duplex {
    readonly id: number;
    _errorMessage?: string;
    _remoteClosed: boolean;
    _remoteReceiveMax: Long;
    _remoteReceived: Long;
    _remoteMaxOffset: number;
    _sentEnd: boolean;
    _remoteSentEnd: boolean;
    protected log: Logger;
    protected isServer: boolean;
    protected _totalSent: Long;
    protected _totalReceived: Long;
    protected _sendMax: Long;
    protected _receiveMax: Long;
    protected _outgoingHeldAmount: Long;
    protected _closed: boolean;
    protected holds: {
        [id: string]: Long;
    };
    protected _incomingData: OffsetSorter;
    protected _outgoingData: DataQueue;
    protected _outgoingDataToRetry: {
        data: Buffer;
        offset: number;
    }[];
    protected outgoingOffset: number;
    protected _receipt?: Buffer;
    protected emittedEnd: boolean;
    protected emittedClose: boolean;
    constructor(opts: StreamOpts);
    get totalSent(): string;
    get totalReceived(): string;
    get sendMax(): string;
    get receiveMax(): string;
    get receipt(): Buffer | undefined;
    get closed(): boolean;
    isOpen(): boolean;
    setSendMax(limit: LongValue): void;
    setReceiveMax(limit: LongValue): void;
    sendTotal(_limit: LongValue, opts?: SendOpts): Promise<void>;
    receiveTotal(_limit: LongValue, opts?: ReceiveOpts): Promise<void>;
    _getAmountStreamCanReceive(): Long;
    _addToIncoming(amount: Long, prepare: IlpPrepare): void;
    _getAmountAvailableToSend(): Long;
    _holdOutgoing(holdId: string, maxAmount?: Long): Long;
    _executeHold(holdId: string): void;
    _cancelHold(holdId: string): void;
    _final(callback: (error: Error | null | undefined) => void): void;
    _destroy(error: Error | null, callback: (error: Error | null) => void): void;
    _write(chunk: Buffer, encoding: string, callback: () => void): void;
    _writev(chunks: {
        chunk: Buffer;
        encoding: string;
    }[], callback: () => void): void;
    _read(size: number): void;
    _hasDataToSend(): boolean;
    _getAvailableDataToSend(size: number): {
        data: Buffer | undefined;
        offset: number;
    };
    _resendOutgoingData(data: Buffer, offset: number): void;
    _isDataBlocked(): number | undefined;
    _getOutgoingOffsets(): {
        current: number;
        max: number;
    };
    _getIncomingOffsets(): {
        max: number;
        current: number;
        maxAcceptable: number;
    };
    _pushIncomingData(data: Buffer, offset: number): void;
    _remoteEnded(err?: Error): void;
    _setReceipt(receipt: Buffer): void;
    protected safeEmit(...args: Parameters<typeof Duplex.prototype.emit>): void;
}
