{"version":3,"file":"server.js","sourceRoot":"","sources":["../../src/server.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events'\nimport * as IlpPacket from 'ilp-packet'\nimport * as ILDCP from 'ilp-protocol-ildcp'\nimport createLogger, { Logger } from 'ilp-logger'\nimport * as cryptoHelper from './crypto'\nimport { Connection, ConnectionOpts } from './connection'\nimport { ServerConnectionPool } from './pool'\nimport { Predictor, Writer } from 'oer-utils'\nimport { Plugin } from './util/plugin-interface'\n\nconst DEFAULT_DISCONNECT_DELAY = 100\n\nexport interface ServerOpts extends ConnectionOpts {\n  serverSecret?: Buffer\n\n  /**\n   * Number of milliseconds to wait between closing the server and disconnecting\n   * the plugin so packets may be safely returned\n   */\n  disconnectDelay?: number\n}\n\nexport interface GenerateAddressSecretOpts {\n  connectionTag?: string\n  receiptNonce?: Buffer\n  receiptSecret?: Buffer\n}\n\n/**\n * STREAM Server that can listen on an account and handle multiple incoming [`Connection`s]{@link Connection}.\n * Note: the connections this refers to are over ILP, not over the Internet.\n *\n * The Server operator should give a unique address and secret (generated by calling\n * [`generateAddressAndSecret`]{@link generateAddressAndSecret}) to each client that it expects to connect.\n *\n * The Server will emit a `'connection'` event when the first packet is received for a specific Connection.\n */\nexport class Server extends EventEmitter {\n  protected serverSecret: Buffer\n  protected plugin: Plugin\n  protected log: Logger\n  protected connectionOpts: ConnectionOpts\n  protected pendingRequests: Promise<void | Buffer> = Promise.resolve()\n  protected disconnectDelay: number\n  private pool?: ServerConnectionPool\n\n  constructor(opts: ServerOpts) {\n    super()\n    this.serverSecret = opts.serverSecret || cryptoHelper.randomBytes(32)\n    this.plugin = opts.plugin\n    this.log = createLogger('ilp-protocol-stream:Server')\n    this.connectionOpts = Object.assign({}, opts, {\n      serverSecret: undefined,\n    })\n    this.disconnectDelay = opts.disconnectDelay || DEFAULT_DISCONNECT_DELAY\n  }\n\n  /**\n   * Event fired when a new [`Connection`]{@link Connection} is received.\n   * The connection event handler should immediately (synchronously) add a\n   * `\"stream\"` event handler to ensure no incoming streams are ignored.\n   * @event connection\n   * @type {Connection}\n   */\n\n  get connected(): boolean {\n    return Boolean(this.pool)\n  }\n\n  /**\n   * Connect the plugin and start listening for incoming connections.\n   *\n   * When a new connection is accepted, the server will emit the \"connection\" event.\n   *\n   * @fires connection\n   */\n  async listen(): Promise<void> {\n    if (this.connected && this.plugin.isConnected()) {\n      return\n    }\n    this.plugin.registerDataHandler((data) => {\n      this.emit('_incoming_prepare')\n      const request = this.handleData(data)\n      this.pendingRequests = this.pendingRequests.then(() => request.finally())\n      return request\n    })\n    await this.plugin.connect()\n    const { clientAddress, assetCode, assetScale } = await ILDCP.fetch(\n      this.plugin.sendData.bind(this.plugin)\n    )\n    this.pool = new ServerConnectionPool(\n      this.serverSecret,\n      {\n        ...this.connectionOpts,\n        isServer: true,\n        plugin: this.plugin,\n        sourceAccount: clientAddress,\n        assetCode,\n        assetScale,\n      },\n      (connection: Connection) => {\n        this.emit('connection', connection)\n      }\n    )\n  }\n\n  /**\n   * End all connections and disconnect the plugin\n   */\n  async close(): Promise<void> {\n    if (!this.pool) {\n      // We're not connected, so there is nothing to do\n      return\n    }\n\n    const serverAccount = this.pool.getServerAccount()\n\n    // Stop handling new requests, and return T99 while the connection is closing.\n    // If an F02 unreachable was returned on new packets: clients would immediately destroy the connection\n    // If an F99 was returned on on new packets: clients would retry with no backoff\n    this.plugin.deregisterDataHandler()\n    this.plugin.registerDataHandler(async () =>\n      IlpPacket.serializeIlpReject({\n        code: IlpPacket.Errors.codes.T99_APPLICATION_ERROR,\n        triggeredBy: serverAccount,\n        message: 'Shutting down server',\n        data: Buffer.alloc(0),\n      })\n    )\n\n    // Wait for in-progress requests to finish so all Fulfills are returned\n    await this.pendingRequests\n    // Allow the plugin time to send the reply packets back before disconnecting it\n    await new Promise((r) => setTimeout(r, this.disconnectDelay))\n\n    // Gracefully close the connection and all streams\n    await this.pool.close()\n\n    this.plugin.deregisterDataHandler()\n    await this.plugin.disconnect()\n\n    this.emit('_close')\n    this.pool = undefined\n  }\n\n  /**\n   * Resolves when the next connection is accepted.\n   *\n   * To handle subsequent connections, the user must call `acceptConnection` again.\n   * Alternatively, the user can listen on the `'connection'` event.\n   */\n  async acceptConnection(): Promise<Connection> {\n    await this.listen()\n    return new Promise((resolve, reject) => {\n      const done = (connection: Connection | undefined) => {\n        this.removeListener('connection', done)\n        this.removeListener('_close', done)\n        if (connection) resolve(connection)\n        else reject(new Error('server closed'))\n      }\n      this.once('connection', done)\n      this.once('_close', done)\n    }) as Promise<Connection>\n  }\n\n  /**\n   * Generate an address and secret for a specific client to enable them to create a connection to the server.\n   *\n   * Two different clients SHOULD NOT be given the same address and secret.\n   *\n   * @param connectionTag Optional connection identifier that will be appended to the ILP address and can be used to identify incoming connections. Can only include characters that can go into an ILP Address\n   * @param receiptNonce Optional nonce to include in STREAM receipts\n   * @param receiptSecret Optional secret to use for signing STREAM receipts\n   */\n  generateAddressAndSecret(opts?: string | GenerateAddressSecretOpts): {\n    destinationAccount: string\n    sharedSecret: Buffer\n    receiptsEnabled: boolean\n  } {\n    if (!this.pool) {\n      throw new Error('Server must be connected to generate address and secret')\n    }\n    let connectionTag = Buffer.alloc(0)\n    let receiptNonce = Buffer.alloc(0)\n    let receiptSecret = Buffer.alloc(0)\n    let receiptsEnabled = false\n    if (opts) {\n      if (typeof opts === 'object') {\n        if (opts.connectionTag) {\n          connectionTag = Buffer.from(opts.connectionTag, 'ascii')\n        }\n        if (!opts.receiptNonce !== !opts.receiptSecret) {\n          throw new Error('receiptNonce and receiptSecret must accompany each other')\n        }\n        if (opts.receiptNonce) {\n          if (opts.receiptNonce.length !== 16) {\n            throw new Error('receiptNonce must be 16 bytes')\n          }\n          receiptsEnabled = true\n          receiptNonce = opts.receiptNonce\n        }\n        if (opts.receiptSecret) {\n          if (opts.receiptSecret.length !== 32) {\n            throw new Error('receiptSecret must be 32 bytes')\n          }\n          receiptSecret = opts.receiptSecret\n        }\n      } else {\n        connectionTag = Buffer.from(opts, 'ascii')\n      }\n    }\n    const tokenNonce = cryptoHelper.generateTokenNonce()\n    const predictor = new Predictor()\n    predictor.writeOctetString(tokenNonce, cryptoHelper.TOKEN_NONCE_LENGTH)\n    predictor.writeVarOctetString(connectionTag)\n    predictor.writeVarOctetString(receiptNonce)\n    predictor.writeVarOctetString(receiptSecret)\n    const writer = new Writer(predictor.length)\n    writer.writeOctetString(tokenNonce, cryptoHelper.TOKEN_NONCE_LENGTH)\n    writer.writeVarOctetString(connectionTag)\n    writer.writeVarOctetString(receiptNonce)\n    writer.writeVarOctetString(receiptSecret)\n\n    const token = cryptoHelper.encryptConnectionAddressToken(this.serverSecret, writer.getBuffer())\n    const sharedSecret = cryptoHelper.generateSharedSecretFromToken(this.serverSecret, token)\n    return {\n      // TODO should this be called serverAccount or serverAddress instead?\n      destinationAccount: `${this.pool.getServerAccount()}.${base64url(token)}`,\n      sharedSecret,\n      receiptsEnabled,\n    }\n  }\n\n  get assetCode(): string {\n    if (!this.pool) {\n      throw new Error('Server must be connected to get asset code.')\n    }\n    return this.pool.getAssetCode()\n  }\n\n  get assetScale(): number {\n    if (!this.pool) {\n      throw new Error('Server must be connected to get asset scale.')\n    }\n    return this.pool.getAssetScale()\n  }\n\n  /**\n   * Parse incoming ILP Prepare packets and pass them to the correct connection\n   */\n  protected async handleData(data: Buffer): Promise<Buffer> {\n    if (!this.pool) {\n      throw new Error('Unexpected call to handleData - server is not connected')\n    }\n\n    try {\n      let prepare: IlpPacket.IlpPrepare\n      try {\n        prepare = IlpPacket.deserializeIlpPrepare(data)\n      } catch (err) {\n        this.log.error('got data that is not an ILP Prepare packet: %h', data)\n        return IlpPacket.serializeIlpReject({\n          code: 'F00',\n          message: `Expected an ILP Prepare packet (type 12), but got packet with type: ${data[0]}`,\n          data: Buffer.alloc(0),\n          triggeredBy: this.pool.getServerAccount(),\n        })\n      }\n\n      const localAddressParts = prepare.destination\n        .replace(`${this.pool.getServerAccount()}.`, '')\n        .split('.')\n      if (localAddressParts.length === 0 || !localAddressParts[0]) {\n        this.log.error(\n          'destination in ILP Prepare packet does not have a Connection ID: %s',\n          prepare.destination\n        )\n        /* Why no error message here?\n        We return an empty message here because we want to minimize the amount of information sent unencrypted\n        that identifies this protocol and specific implementation for the rest of the network. For example,\n        if every implementation returns a slightly different message here, you could determine what type of\n        endpoint is listening on a particular ILP address just by changing the last character of the destination\n        in a packet and seeing what error message you get back.\n        Apologies if this caused additional debugging time for you! */\n        throw new IlpPacket.Errors.UnreachableError('')\n      }\n      const connectionId = localAddressParts[0]\n\n      const connection = await this.pool\n        .getConnection(connectionId, prepare)\n        .catch((_err: Error) => {\n          // See \"Why no error message here?\" note above\n          throw new IlpPacket.Errors.UnreachableError('')\n        })\n      const fulfill = await connection.handlePrepare(prepare)\n      return IlpPacket.serializeIlpFulfill(fulfill)\n    } catch (err) {\n      const triggeredBy = this.pool.getServerAccount()\n\n      if (IlpPacket.isIlpError(err)) {\n        return IlpPacket.errorToReject(triggeredBy, err)\n      } else {\n        this.log.error('error handling prepare:', err)\n\n        return IlpPacket.serializeIlpReject({\n          // TODO should the default be F00 or T00?\n          code: 'F00',\n          message: '',\n          data: Buffer.alloc(0),\n          triggeredBy,\n        })\n      }\n    }\n  }\n}\n\n/**\n * Creates a [`Server`]{@link Server} and resolves when the server is connected and listening\n */\nexport async function createServer(opts: ServerOpts): Promise<Server> {\n  const server = new Server(opts)\n  await server.listen()\n  return server\n}\n\nfunction base64url(buffer: Buffer) {\n  return buffer.toString('base64').replace(/=+$/, '').replace(/\\+/g, '-').replace(/\\//g, '_')\n}\n"]}