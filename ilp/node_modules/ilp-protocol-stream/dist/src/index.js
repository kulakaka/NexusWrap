"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createConnection = exports.RECEIPT_VERSION = exports.verifyReceipt = exports.decodeReceipt = exports.createReceipt = exports.createServer = exports.Server = exports.DataAndMoneyStream = exports.Connection = void 0;
const ILDCP = __importStar(require("ilp-protocol-ildcp"));
const IlpPacket = __importStar(require("ilp-packet"));
const ilp_logger_1 = __importDefault(require("ilp-logger"));
require("./util/formatters");
const connection_1 = require("./connection");
var connection_2 = require("./connection");
Object.defineProperty(exports, "Connection", { enumerable: true, get: function () { return connection_2.Connection; } });
var stream_1 = require("./stream");
Object.defineProperty(exports, "DataAndMoneyStream", { enumerable: true, get: function () { return stream_1.DataAndMoneyStream; } });
var server_1 = require("./server");
Object.defineProperty(exports, "Server", { enumerable: true, get: function () { return server_1.Server; } });
Object.defineProperty(exports, "createServer", { enumerable: true, get: function () { return server_1.createServer; } });
var receipt_1 = require("./util/receipt");
Object.defineProperty(exports, "createReceipt", { enumerable: true, get: function () { return receipt_1.createReceipt; } });
Object.defineProperty(exports, "decodeReceipt", { enumerable: true, get: function () { return receipt_1.decodeReceipt; } });
Object.defineProperty(exports, "verifyReceipt", { enumerable: true, get: function () { return receipt_1.verifyReceipt; } });
Object.defineProperty(exports, "RECEIPT_VERSION", { enumerable: true, get: function () { return receipt_1.RECEIPT_VERSION; } });
async function createConnection(opts) {
    const plugin = opts.plugin;
    await plugin.connect();
    const log = (0, ilp_logger_1.default)('ilp-protocol-stream:Client');
    const { clientAddress, assetCode, assetScale } = await ILDCP.fetch(plugin.sendData.bind(plugin), {
        expiresAt: opts.getExpiry && opts.getExpiry('peer.config'),
    });
    const connection = await connection_1.Connection.build(Object.assign(Object.assign({}, opts), { sourceAccount: clientAddress, assetCode,
        assetScale, isServer: false, plugin }));
    plugin.registerDataHandler(async (data) => {
        let prepare;
        try {
            prepare = IlpPacket.deserializeIlpPrepare(data);
        }
        catch (err) {
            log.error('got data that is not an ILP Prepare packet: %h', data);
            return IlpPacket.serializeIlpReject({
                code: 'F00',
                message: `Expected an ILP Prepare packet (type 12), but got packet with type: ${data[0]}`,
                data: Buffer.alloc(0),
                triggeredBy: clientAddress,
            });
        }
        try {
            const fulfill = await connection.handlePrepare(prepare);
            return IlpPacket.serializeIlpFulfill(fulfill);
        }
        catch (err) {
            if (IlpPacket.isIlpError(err)) {
                return IlpPacket.errorToReject(clientAddress, err);
            }
            else {
                log.error('error handling prepare:', err);
                return IlpPacket.serializeIlpReject({
                    code: 'F00',
                    message: '',
                    data: Buffer.alloc(0),
                    triggeredBy: clientAddress,
                });
            }
        }
    });
    connection.once('close', () => {
        plugin.deregisterDataHandler();
        plugin
            .disconnect()
            .then(() => log.info('plugin disconnected'))
            .catch((err) => log.error('error disconnecting plugin:', err));
    });
    await connection.connect();
    return connection;
}
exports.createConnection = createConnection;
//# sourceMappingURL=index.js.map