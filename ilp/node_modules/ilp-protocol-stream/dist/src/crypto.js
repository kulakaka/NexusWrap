"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateIncomingPacketId = exports.generateFulfillment = exports.generateFulfillmentKey = exports.generatePskEncryptionKey = exports.generateRandomCondition = exports.generateTokenNonce = exports.ENCRYPTION_OVERHEAD = exports.TOKEN_NONCE_LENGTH = exports.randomBytes = exports.hmac = exports.hash = exports.generateReceiptHMAC = exports.generateSharedSecretFromToken = exports.encryptConnectionAddressToken = exports.encrypt = exports.decryptConnectionAddressToken = exports.decrypt = void 0;
const crypto_node_1 = require("./util/crypto-node");
var crypto_node_2 = require("./util/crypto-node");
Object.defineProperty(exports, "decrypt", { enumerable: true, get: function () { return crypto_node_2.decrypt; } });
Object.defineProperty(exports, "decryptConnectionAddressToken", { enumerable: true, get: function () { return crypto_node_2.decryptConnectionAddressToken; } });
Object.defineProperty(exports, "encrypt", { enumerable: true, get: function () { return crypto_node_2.encrypt; } });
Object.defineProperty(exports, "encryptConnectionAddressToken", { enumerable: true, get: function () { return crypto_node_2.encryptConnectionAddressToken; } });
Object.defineProperty(exports, "generateSharedSecretFromToken", { enumerable: true, get: function () { return crypto_node_2.generateSharedSecretFromToken; } });
Object.defineProperty(exports, "generateReceiptHMAC", { enumerable: true, get: function () { return crypto_node_2.generateReceiptHMAC; } });
Object.defineProperty(exports, "hash", { enumerable: true, get: function () { return crypto_node_2.hash; } });
Object.defineProperty(exports, "hmac", { enumerable: true, get: function () { return crypto_node_2.hmac; } });
Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function () { return crypto_node_2.randomBytes; } });
exports.TOKEN_NONCE_LENGTH = 18;
const ENCRYPTION_KEY_STRING = Buffer.from('ilp_stream_encryption', 'utf8');
const FULFILLMENT_GENERATION_STRING = Buffer.from('ilp_stream_fulfillment', 'utf8');
const PACKET_ID_STRING = Buffer.from('ilp_stream_packet_id', 'utf8');
exports.ENCRYPTION_OVERHEAD = 28;
function generateTokenNonce() {
    return (0, crypto_node_1.randomBytes)(exports.TOKEN_NONCE_LENGTH);
}
exports.generateTokenNonce = generateTokenNonce;
function generateRandomCondition() {
    return (0, crypto_node_1.randomBytes)(32);
}
exports.generateRandomCondition = generateRandomCondition;
function generatePskEncryptionKey(sharedSecret) {
    return (0, crypto_node_1.hmac)(sharedSecret, ENCRYPTION_KEY_STRING);
}
exports.generatePskEncryptionKey = generatePskEncryptionKey;
function generateFulfillmentKey(sharedSecret) {
    return (0, crypto_node_1.hmac)(sharedSecret, FULFILLMENT_GENERATION_STRING);
}
exports.generateFulfillmentKey = generateFulfillmentKey;
function generateFulfillment(fulfillmentKey, data) {
    return (0, crypto_node_1.hmac)(fulfillmentKey, data);
}
exports.generateFulfillment = generateFulfillment;
function generateIncomingPacketId(sharedSecret, sequence) {
    return (0, crypto_node_1.hmac)(sharedSecret, Buffer.concat([PACKET_ID_STRING, Buffer.from(sequence.toBytes())]));
}
exports.generateIncomingPacketId = generateIncomingPacketId;
//# sourceMappingURL=crypto.js.map