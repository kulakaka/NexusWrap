"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.multiplyDivide = exports.multiplyDivideRound = exports.multiplyDivideCeil = exports.multiplyDivideFloor = exports.checkedMultiply = exports.checkedSubtract = exports.checkedAdd = exports.countDigits = exports.minLongs = exports.minLong = exports.maxLong = exports.longFromValue = void 0;
const long_1 = __importDefault(require("long"));
function longFromValue(value, unsigned) {
    if (typeof value === 'number') {
        if (unsigned && value < 0) {
            throw new Error('Expected positive number');
        }
        return long_1.default.fromNumber(value, unsigned);
    }
    if (typeof value === 'string') {
        if (unsigned && value[0] === '-') {
            throw new Error('Expected positive number');
        }
        const longValue = long_1.default.fromString(value, unsigned);
        if (longValue.toString() !== value) {
            throw new Error('Value ' + value + ' does not fit in a Long.');
        }
        return longValue;
    }
    if (value.unsigned !== unsigned) {
        throw new Error('Expected ' + (unsigned ? 'unsigned' : 'signed') + ' Long');
    }
    return value;
}
exports.longFromValue = longFromValue;
function maxLong(a, b) {
    return a.greaterThan(b) ? a : b;
}
exports.maxLong = maxLong;
function minLong(a, b) {
    return a.lessThan(b) ? a : b;
}
exports.minLong = minLong;
function minLongs(values) {
    let min = values[0];
    for (let i = 1; i < values.length; i++) {
        min = minLong(min, values[i]);
    }
    return min;
}
exports.minLongs = minLongs;
function countDigits(value) {
    let digits = 0;
    while (!value.isZero()) {
        digits++;
        value = value.divide(10);
    }
    return digits;
}
exports.countDigits = countDigits;
function checkedAdd(a, b) {
    const sum = a.add(b);
    const overflow = sum.lessThan(a) || sum.lessThan(b);
    return {
        sum: overflow ? long_1.default.MAX_UNSIGNED_VALUE : sum,
        overflow,
    };
}
exports.checkedAdd = checkedAdd;
function checkedSubtract(a, b) {
    const difference = a.subtract(b);
    const underflow = difference.greaterThan(a) && difference.greaterThan(b);
    return {
        difference: underflow ? long_1.default.UZERO : difference,
        underflow,
    };
}
exports.checkedSubtract = checkedSubtract;
function checkedMultiply(a, b) {
    const product = a.multiply(b);
    const overflow = product.lessThan(a) || product.lessThan(b);
    return {
        product: overflow ? long_1.default.MAX_UNSIGNED_VALUE : product,
        overflow,
    };
}
exports.checkedMultiply = checkedMultiply;
function multiplyDivideFloor(a, b, c) {
    return multiplyDivide(a, b, c).quo;
}
exports.multiplyDivideFloor = multiplyDivideFloor;
function multiplyDivideCeil(a, b, c) {
    const { quo, rem } = multiplyDivide(a, b, c);
    if (quo.equals(long_1.default.MAX_UNSIGNED_VALUE))
        return quo;
    return quo.add(rem.isZero() ? 0 : 1);
}
exports.multiplyDivideCeil = multiplyDivideCeil;
function multiplyDivideRound(a, b, c) {
    const { quo, rem } = multiplyDivide(a, b, c);
    if (quo.equals(long_1.default.MAX_UNSIGNED_VALUE))
        return quo;
    const roundUp = !rem.isZero() &&
        (c.isOdd()
            ? rem.greaterThan(c.divide(2))
            : rem.greaterThanOrEqual(c.divide(2)));
    return roundUp ? quo.add(long_1.default.UONE) : quo;
}
exports.multiplyDivideRound = multiplyDivideRound;
function multiplyDivide(a, b, c) {
    let quo = long_1.default.UZERO;
    let rem = long_1.default.UZERO;
    let qn = b.divide(c);
    let rn = b.modulo(c);
    while (!a.isZero()) {
        const oldQuo = quo;
        if (!a.and(long_1.default.UONE).isZero()) {
            quo = quo.add(qn);
            rem = rem.add(rn);
            if (rem.greaterThanOrEqual(c)) {
                quo = quo.add(long_1.default.UONE);
                rem = rem.subtract(c);
            }
        }
        if (quo.lessThan(oldQuo)) {
            return { quo: long_1.default.MAX_UNSIGNED_VALUE, rem: long_1.default.UZERO };
        }
        a = a.shiftRightUnsigned(1);
        qn = qn.shiftLeft(1);
        rn = rn.shiftLeft(1);
        if (rn.greaterThanOrEqual(c)) {
            qn = qn.add(long_1.default.UONE);
            rn = rn.subtract(c);
        }
    }
    return { quo, rem };
}
exports.multiplyDivide = multiplyDivide;
long_1.default.prototype['toJSON'] = function () {
    return this.toString();
};
//# sourceMappingURL=long.js.map