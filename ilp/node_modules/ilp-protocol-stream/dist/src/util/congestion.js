"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CongestionController = void 0;
const long_1 = __importDefault(require("long"));
const ilp_logger_1 = __importDefault(require("ilp-logger"));
const oer_utils_1 = require("oer-utils");
const long_2 = require("./long");
const log = (0, ilp_logger_1.default)('ilp-protocol-stream:Congestion');
class CongestionController {
    constructor(opts) {
        this._testMaximumPacketAmount = long_1.default.MAX_UNSIGNED_VALUE;
        this._maximumPacketAmount = long_1.default.MAX_UNSIGNED_VALUE;
        this._fixedPacketAmount = opts.maximumPacketAmount || long_1.default.MAX_UNSIGNED_VALUE;
    }
    get testMaximumPacketAmount() {
        return this._testMaximumPacketAmount;
    }
    get maximumPacketAmount() {
        return (0, long_2.minLong)(this._maximumPacketAmount, this._fixedPacketAmount);
    }
    setMaximumAmounts(amount) {
        this._testMaximumPacketAmount = amount;
        this._maximumPacketAmount = amount;
    }
    onFulfill(amountSent) {
        const maximumPacketAmount = this.maximumPacketAmount;
        const shouldRaiseLimit = amountSent.equals(this._testMaximumPacketAmount) &&
            this._testMaximumPacketAmount.lessThan(maximumPacketAmount);
        if (!shouldRaiseLimit)
            return;
        let newTestMax;
        const isMaxPacketAmountKnown = maximumPacketAmount.notEquals(long_1.default.MAX_UNSIGNED_VALUE);
        if (isMaxPacketAmountKnown) {
            const additiveIncrease = maximumPacketAmount.divide(10);
            newTestMax = (0, long_2.minLong)((0, long_2.checkedAdd)(this._testMaximumPacketAmount, additiveIncrease).sum, maximumPacketAmount);
            log.trace('last packet amount was successful (max packet amount: %s), raising packet amount from %s to: %s', maximumPacketAmount, this._testMaximumPacketAmount, newTestMax);
        }
        else {
            newTestMax = (0, long_2.checkedMultiply)(this._testMaximumPacketAmount, long_1.default.fromNumber(2, true)).product;
            log.trace('last packet amount was successful, unknown max packet amount, raising packet amount from: %s to: %s', this._testMaximumPacketAmount, newTestMax);
        }
        this._testMaximumPacketAmount = newTestMax;
    }
    onAmountTooLargeError(reject, amountSent) {
        let receivedAmount;
        let maximumAmount;
        try {
            const reader = oer_utils_1.Reader.from(reject.data);
            receivedAmount = reader.readUInt64Long();
            maximumAmount = reader.readUInt64Long();
        }
        catch (err) {
            receivedAmount = undefined;
            maximumAmount = undefined;
        }
        if (receivedAmount && maximumAmount && receivedAmount.greaterThan(maximumAmount)) {
            const newMaximum = (0, long_2.multiplyDivideFloor)(amountSent, maximumAmount, receivedAmount);
            log.trace('reducing maximum packet amount from %s to %s', this._maximumPacketAmount, newMaximum);
            this._maximumPacketAmount = newMaximum;
            this._testMaximumPacketAmount = newMaximum;
        }
        else {
            this._maximumPacketAmount = amountSent.subtract(1);
            this._testMaximumPacketAmount = this.maximumPacketAmount.divide(2);
        }
        return this.maximumPacketAmount;
    }
    onInsufficientLiquidityError(reject, amountSent) {
        const minPacketAmount = (0, long_2.minLong)(amountSent, this._testMaximumPacketAmount);
        const newTestAmount = minPacketAmount.subtract(minPacketAmount.divide(3));
        this._testMaximumPacketAmount = (0, long_2.maxLong)(long_1.default.fromNumber(2, true), newTestAmount);
        log.warn('got T04: Insufficient Liquidity error triggered by: %s reducing the packet amount to %s', reject.triggeredBy, this._testMaximumPacketAmount);
    }
}
exports.CongestionController = CongestionController;
//# sourceMappingURL=congestion.js.map