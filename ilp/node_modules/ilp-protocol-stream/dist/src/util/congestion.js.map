{"version":3,"file":"congestion.js","sourceRoot":"","sources":["../../../src/util/congestion.ts"],"names":[],"mappings":"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","sourcesContent":["import Long from 'long'\nimport createLogger from 'ilp-logger'\nimport * as IlpPacket from 'ilp-packet'\nimport { Reader } from 'oer-utils'\nimport { checkedAdd, checkedMultiply, maxLong, minLong, multiplyDivideFloor } from './long'\n\nconst log = createLogger('ilp-protocol-stream:Congestion')\n\ninterface CongestionOptions {\n  /** Maximum amount per packet, even if F08 reports larger */\n  maximumPacketAmount?: Long\n}\n\nexport class CongestionController {\n  /** Used to probe for the Maximum Packet Amount if the connectors don't tell us directly */\n  private _testMaximumPacketAmount: Long\n  /** The path's Maximum Packet Amount, discovered through F08 errors */\n  private _maximumPacketAmount: Long\n  /** The sender-chosen maximum packet amount. */\n  private _fixedPacketAmount: Long\n\n  constructor(opts: CongestionOptions) {\n    this._testMaximumPacketAmount = Long.MAX_UNSIGNED_VALUE\n    this._maximumPacketAmount = Long.MAX_UNSIGNED_VALUE\n    this._fixedPacketAmount = opts.maximumPacketAmount || Long.MAX_UNSIGNED_VALUE\n  }\n\n  get testMaximumPacketAmount(): Long {\n    return this._testMaximumPacketAmount\n  }\n\n  get maximumPacketAmount(): Long {\n    return minLong(this._maximumPacketAmount, this._fixedPacketAmount)\n  }\n\n  setMaximumAmounts(amount: Long) {\n    this._testMaximumPacketAmount = amount\n    this._maximumPacketAmount = amount\n  }\n\n  onFulfill(amountSent: Long) {\n    const maximumPacketAmount = this.maximumPacketAmount\n    const shouldRaiseLimit =\n      amountSent.equals(this._testMaximumPacketAmount) &&\n      this._testMaximumPacketAmount.lessThan(maximumPacketAmount)\n    if (!shouldRaiseLimit) return\n    // If we're trying to pinpoint the Maximum Packet Amount, raise\n    // the limit because we know that the testMaximumPacketAmount works\n\n    let newTestMax\n    const isMaxPacketAmountKnown = maximumPacketAmount.notEquals(Long.MAX_UNSIGNED_VALUE)\n    if (isMaxPacketAmountKnown) {\n      // Take the `max packet amount / 10` and then add it to the last test packet amount for an additive increase.\n      const additiveIncrease = maximumPacketAmount.divide(10)\n      newTestMax = minLong(\n        checkedAdd(this._testMaximumPacketAmount, additiveIncrease).sum,\n        maximumPacketAmount\n      )\n      log.trace(\n        'last packet amount was successful (max packet amount: %s), raising packet amount from %s to: %s',\n        maximumPacketAmount,\n        this._testMaximumPacketAmount,\n        newTestMax\n      )\n    } else {\n      // Increase by 2 times in this case since we do not know the max packet amount\n      newTestMax = checkedMultiply(this._testMaximumPacketAmount, Long.fromNumber(2, true)).product\n      log.trace(\n        'last packet amount was successful, unknown max packet amount, raising packet amount from: %s to: %s',\n        this._testMaximumPacketAmount,\n        newTestMax\n      )\n    }\n    this._testMaximumPacketAmount = newTestMax\n  }\n\n  // Returns the new maximum packet amount.\n  onAmountTooLargeError(reject: IlpPacket.IlpReject, amountSent: Long): Long {\n    let receivedAmount: Long | undefined\n    let maximumAmount: Long | undefined\n    try {\n      const reader = Reader.from(reject.data)\n      receivedAmount = reader.readUInt64Long()\n      maximumAmount = reader.readUInt64Long()\n    } catch (err) {\n      receivedAmount = undefined\n      maximumAmount = undefined\n    }\n\n    if (receivedAmount && maximumAmount && receivedAmount.greaterThan(maximumAmount)) {\n      const newMaximum = multiplyDivideFloor(amountSent, maximumAmount, receivedAmount)\n      log.trace(\n        'reducing maximum packet amount from %s to %s',\n        this._maximumPacketAmount,\n        newMaximum\n      )\n      this._maximumPacketAmount = newMaximum\n      this._testMaximumPacketAmount = newMaximum\n    } else {\n      // Connector didn't include amounts\n      this._maximumPacketAmount = amountSent.subtract(1)\n      this._testMaximumPacketAmount = this.maximumPacketAmount.divide(2)\n    }\n    return this.maximumPacketAmount\n  }\n\n  onInsufficientLiquidityError(reject: IlpPacket.IlpReject, amountSent: Long) {\n    // TODO add more sophisticated logic for handling bandwidth-related connector errors\n    // we should really be keeping track of the amount sent within a given window of time\n    // and figuring out the max amount per window. this logic is just a stand in to fix\n    // infinite retries when it runs into this type of error\n    const minPacketAmount = minLong(amountSent, this._testMaximumPacketAmount)\n    const newTestAmount = minPacketAmount.subtract(minPacketAmount.divide(3))\n    // don't let it go to zero, set to 2 so that the other side gets at least 1 after the exchange rate is taken into account\n    this._testMaximumPacketAmount = maxLong(Long.fromNumber(2, true), newTestAmount)\n    log.warn(\n      'got T04: Insufficient Liquidity error triggered by: %s reducing the packet amount to %s',\n      reject.triggeredBy,\n      this._testMaximumPacketAmount\n    )\n  }\n}\n"]}