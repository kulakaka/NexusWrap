{"version":3,"file":"crypto-node.js","sourceRoot":"","sources":["../../../src/util/crypto-node.ts"],"names":[],"mappings":"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","sourcesContent":["import * as crypto from 'crypto'\nimport assert from 'assert'\n\nconst HASH_ALGORITHM = 'sha256'\nconst ENCRYPTION_ALGORITHM = 'aes-256-gcm'\nconst IV_LENGTH = 12\nconst AUTH_TAG_LENGTH = 16\nconst SHARED_SECRET_GENERATION_STRING = Buffer.from('ilp_stream_shared_secret', 'utf8')\n\nexport const randomBytes = crypto.randomBytes\n\nexport async function hash(preimage: Buffer): Promise<Buffer> {\n  const h = crypto.createHash(HASH_ALGORITHM)\n  h.update(preimage)\n  return Promise.resolve(h.digest())\n}\n\nexport async function encrypt(pskEncryptionKey: Buffer, ...buffers: Buffer[]): Promise<Buffer> {\n  return Promise.resolve(encryptSync(pskEncryptionKey, ...buffers))\n}\n\nfunction encryptSync(pskEncryptionKey: Buffer, ...buffers: Buffer[]): Buffer {\n  const iv = crypto.randomBytes(IV_LENGTH)\n  const cipher = crypto.createCipheriv(ENCRYPTION_ALGORITHM, pskEncryptionKey, iv)\n\n  const ciphertext = []\n  for (const buffer of buffers) {\n    ciphertext.push(cipher.update(buffer))\n  }\n  ciphertext.push(cipher.final())\n  const tag = cipher.getAuthTag()\n  ciphertext.unshift(iv, tag)\n  return Buffer.concat(ciphertext)\n}\n\nexport async function decrypt(pskEncryptionKey: Buffer, data: Buffer): Promise<Buffer> {\n  return Promise.resolve(decryptSync(pskEncryptionKey, data))\n}\n\nfunction decryptSync(pskEncryptionKey: Buffer, data: Buffer): Buffer {\n  assert(data.length > 0, 'cannot decrypt empty buffer')\n  const nonce = data.slice(0, IV_LENGTH)\n  const tag = data.slice(IV_LENGTH, IV_LENGTH + AUTH_TAG_LENGTH)\n  const encrypted = data.slice(IV_LENGTH + AUTH_TAG_LENGTH)\n  const decipher = crypto.createDecipheriv(ENCRYPTION_ALGORITHM, pskEncryptionKey, nonce)\n  decipher.setAuthTag(tag)\n\n  return Buffer.concat([decipher.update(encrypted), decipher.final()])\n}\n\nexport async function hmac(key: Buffer, message: Buffer): Promise<Buffer> {\n  return Promise.resolve(hmacSync(key, message))\n}\n\nfunction hmacSync(key: Buffer, message: Buffer): Buffer {\n  const h = crypto.createHmac(HASH_ALGORITHM, key)\n  h.update(message)\n  return h.digest()\n}\n\nexport function generateSharedSecretFromToken(seed: Buffer, token: Buffer): Buffer {\n  const keygen = hmacSync(seed, SHARED_SECRET_GENERATION_STRING)\n  const sharedSecret = hmacSync(keygen, token)\n  return sharedSecret\n}\n\nexport function generateReceiptHMAC(secret: Buffer, message: Buffer): Buffer {\n  return hmacSync(secret, message)\n}\n\nexport function encryptConnectionAddressToken(seed: Buffer, token: Buffer): Buffer {\n  return encryptSync(seed, token)\n}\n\nexport function decryptConnectionAddressToken(seed: Buffer, token: Buffer): Buffer {\n  return decryptSync(seed, token)\n}\n"]}