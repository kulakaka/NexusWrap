{"version":3,"file":"crypto-browser.js","sourceRoot":"","sources":["../../../src/util/crypto-browser.ts"],"names":[],"mappings":"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","sourcesContent":["const { crypto } = self\nconst HASH_ALGORITHM = 'SHA-256'\nconst ENCRYPTION_ALGORITHM = 'AES-GCM'\nconst IV_LENGTH = 12\nconst AUTH_TAG_BYTES = 16\nconst AUTH_TAG_BITS = 8 * AUTH_TAG_BYTES\nconst CACHE_EXPIRY = 30000\n\n// Cache keys so that `subtle.importKey` doesn't need to be called for every operation.\n// It would be nicer to just store the `CryptoKey`s on the stream `Connection`, but\n// that's tricky since this file takes the place of `crypto-node.ts`.\nclass KeyCache {\n  private cache: Map<Buffer, CacheEntry> = new Map()\n\n  cleanup() {\n    const now = Date.now()\n    for (const [cacheData, cacheEntry] of this.cache) {\n      if (now - cacheEntry.accessTime > CACHE_EXPIRY) {\n        this.cache.delete(cacheData)\n      }\n    }\n  }\n\n  async importKey(\n    keyData: Buffer,\n    algorithm: string | HmacImportParams | AesKeyAlgorithm,\n    keyUsages: KeyUsage[]\n  ): Promise<CryptoKey> {\n    const oldEntry = this.cache.get(keyData)\n    if (oldEntry) {\n      oldEntry.accessTime = Date.now()\n      return oldEntry.keyObject\n    }\n    const keyObject = await crypto.subtle.importKey(\n      'raw',\n      keyData,\n      algorithm,\n      false, // extractable\n      keyUsages\n    )\n    this.cache.set(keyData, {\n      keyObject,\n      accessTime: Date.now(),\n    })\n    return keyObject\n  }\n}\n\ninterface CacheEntry {\n  keyObject: CryptoKey\n  accessTime: number // milliseconds since epoch\n}\n\nconst hmacKeyCache = new KeyCache()\nconst aesKeyCache = new KeyCache()\n\nsetInterval(() => {\n  hmacKeyCache.cleanup()\n  aesKeyCache.cleanup()\n}, 30000)\n\nexport async function hash(preimage: Buffer): Promise<Buffer> {\n  const digest = await crypto.subtle.digest({ name: HASH_ALGORITHM }, preimage)\n  return Buffer.from(digest)\n}\n\nexport async function encrypt(pskEncryptionKey: Buffer, ...buffers: Buffer[]): Promise<Buffer> {\n  const iv = randomBytes(IV_LENGTH)\n  const key = await aesKeyCache.importKey(pskEncryptionKey, ENCRYPTION_ALGORITHM, [\n    'encrypt',\n    'decrypt',\n  ])\n  const ciphertext = await crypto.subtle.encrypt(\n    {\n      name: ENCRYPTION_ALGORITHM,\n      iv,\n      tagLength: AUTH_TAG_BITS,\n    },\n    key,\n    Buffer.concat(buffers)\n  )\n  const tagStart = ciphertext.byteLength - AUTH_TAG_BYTES\n  const tag = ciphertext.slice(tagStart)\n  const data = ciphertext.slice(0, tagStart)\n  return Buffer.concat([Buffer.from(iv), Buffer.from(tag), Buffer.from(data)])\n}\n\nexport async function decrypt(pskEncryptionKey: Buffer, data: Buffer): Promise<Buffer> {\n  const nonce = data.slice(0, IV_LENGTH)\n  const tag = data.slice(IV_LENGTH, IV_LENGTH + AUTH_TAG_BYTES)\n  const cipherdata = data.slice(IV_LENGTH + AUTH_TAG_BYTES)\n  const key = await aesKeyCache.importKey(pskEncryptionKey, ENCRYPTION_ALGORITHM, [\n    'encrypt',\n    'decrypt',\n  ])\n  const decryptedData = await crypto.subtle.decrypt(\n    {\n      name: ENCRYPTION_ALGORITHM,\n      iv: nonce,\n    },\n    key,\n    Buffer.concat([cipherdata, tag])\n  )\n  return Buffer.from(decryptedData)\n}\n\nconst HMAC_ALGORITHM = {\n  name: 'HMAC',\n  hash: { name: HASH_ALGORITHM },\n}\n\nexport async function hmac(key: Buffer, message: Buffer): Promise<Buffer> {\n  const hmacKey = await hmacKeyCache.importKey(key, HMAC_ALGORITHM, ['sign', 'verify'])\n  const signature = await crypto.subtle.sign('HMAC', hmacKey, message)\n  return Buffer.from(signature)\n}\n\nexport function randomBytes(size: number): Buffer {\n  const randArray = new Uint8Array(size)\n  const randValues = crypto.getRandomValues(randArray)\n  return Buffer.from(randValues)\n}\n\n// Dummy function to make typescript happy. This function is only ever used by\n// the server, which is not included in the browser build.\nexport function generateSharedSecretFromToken(_seed: Buffer, _token: Buffer): Buffer {\n  throw new Error('unreachable in browser')\n}\n\n// Dummy function to make typescript happy. This function is only ever used by\n// the server, which is not included in the browser build.\nexport function generateReceiptHMAC(_secret: Buffer, _message: Buffer): Buffer {\n  throw new Error('unreachable in browser')\n}\n\n// Dummy function to make typescript happy. This function is only ever used by\n// the server, which is not included in the browser build.\nexport function encryptConnectionAddressToken(_seed: Buffer, _token: Buffer): Buffer {\n  throw new Error('unreachable in browser')\n}\n\n// Dummy function to make typescript happy. This function is only ever used by\n// the server, which is not included in the browser build.\nexport function decryptConnectionAddressToken(_seed: Buffer, _token: Buffer): Buffer {\n  throw new Error('unreachable in browser')\n}\n"]}