{"version":3,"file":"crypto.js","sourceRoot":"","sources":["../../src/crypto.ts"],"names":[],"mappings":";;;AACA,oDAAsD;AACtD,kDAU2B;AATzB,sGAAA,OAAO,OAAA;AACP,4HAAA,6BAA6B,OAAA;AAC7B,sGAAA,OAAO,OAAA;AACP,4HAAA,6BAA6B,OAAA;AAC7B,4HAAA,6BAA6B,OAAA;AAC7B,kHAAA,mBAAmB,OAAA;AACnB,mGAAA,IAAI,OAAA;AACJ,mGAAA,IAAI,OAAA;AACJ,0GAAA,WAAW,OAAA;AAGA,QAAA,kBAAkB,GAAG,EAAE,CAAA;AACpC,MAAM,qBAAqB,GAAG,MAAM,CAAC,IAAI,CAAC,uBAAuB,EAAE,MAAM,CAAC,CAAA;AAC1E,MAAM,6BAA6B,GAAG,MAAM,CAAC,IAAI,CAAC,wBAAwB,EAAE,MAAM,CAAC,CAAA;AACnF,MAAM,gBAAgB,GAAG,MAAM,CAAC,IAAI,CAAC,sBAAsB,EAAE,MAAM,CAAC,CAAA;AACvD,QAAA,mBAAmB,GAAG,EAAE,CAAA;AAErC,SAAgB,kBAAkB;IAChC,OAAO,IAAA,yBAAW,EAAC,0BAAkB,CAAC,CAAA;AACxC,CAAC;AAFD,gDAEC;AAED,SAAgB,uBAAuB;IACrC,OAAO,IAAA,yBAAW,EAAC,EAAE,CAAC,CAAA;AACxB,CAAC;AAFD,0DAEC;AAED,SAAgB,wBAAwB,CAAC,YAAoB;IAC3D,OAAO,IAAA,kBAAI,EAAC,YAAY,EAAE,qBAAqB,CAAC,CAAA;AAClD,CAAC;AAFD,4DAEC;AAED,SAAgB,sBAAsB,CAAC,YAAoB;IACzD,OAAO,IAAA,kBAAI,EAAC,YAAY,EAAE,6BAA6B,CAAC,CAAA;AAC1D,CAAC;AAFD,wDAEC;AAED,SAAgB,mBAAmB,CAAC,cAAsB,EAAE,IAAY;IACtE,OAAO,IAAA,kBAAI,EAAC,cAAc,EAAE,IAAI,CAAC,CAAA;AACnC,CAAC;AAFD,kDAEC;AAED,SAAgB,wBAAwB,CAAC,YAAoB,EAAE,QAAc;IAC3E,OAAO,IAAA,kBAAI,EAAC,YAAY,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC,gBAAgB,EAAE,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,CAAA;AAC/F,CAAC;AAFD,4DAEC","sourcesContent":["// When webpacked, \"crypto-node\" is replaced with \"crypto-browser\".\nimport { hmac, randomBytes } from './util/crypto-node'\nexport {\n  decrypt,\n  decryptConnectionAddressToken, // only in node, not browser\n  encrypt,\n  encryptConnectionAddressToken, // only in node, not browser\n  generateSharedSecretFromToken, // only in node, not browser\n  generateReceiptHMAC, // only in node, not browser\n  hash,\n  hmac,\n  randomBytes,\n} from './util/crypto-node'\n\nexport const TOKEN_NONCE_LENGTH = 18\nconst ENCRYPTION_KEY_STRING = Buffer.from('ilp_stream_encryption', 'utf8')\nconst FULFILLMENT_GENERATION_STRING = Buffer.from('ilp_stream_fulfillment', 'utf8')\nconst PACKET_ID_STRING = Buffer.from('ilp_stream_packet_id', 'utf8')\nexport const ENCRYPTION_OVERHEAD = 28\n\nexport function generateTokenNonce(): Buffer {\n  return randomBytes(TOKEN_NONCE_LENGTH)\n}\n\nexport function generateRandomCondition(): Buffer {\n  return randomBytes(32)\n}\n\nexport function generatePskEncryptionKey(sharedSecret: Buffer): Promise<Buffer> {\n  return hmac(sharedSecret, ENCRYPTION_KEY_STRING)\n}\n\nexport function generateFulfillmentKey(sharedSecret: Buffer): Promise<Buffer> {\n  return hmac(sharedSecret, FULFILLMENT_GENERATION_STRING)\n}\n\nexport function generateFulfillment(fulfillmentKey: Buffer, data: Buffer): Promise<Buffer> {\n  return hmac(fulfillmentKey, data)\n}\n\nexport function generateIncomingPacketId(sharedSecret: Buffer, sequence: Long): Promise<Buffer> {\n  return hmac(sharedSecret, Buffer.concat([PACKET_ID_STRING, Buffer.from(sequence.toBytes())]))\n}\n"]}