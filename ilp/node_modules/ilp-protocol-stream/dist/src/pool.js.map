{"version":3,"file":"pool.js","sourceRoot":"","sources":["../../src/pool.ts"],"names":[],"mappings":"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","sourcesContent":["import createLogger from 'ilp-logger'\nimport * as IlpPacket from 'ilp-packet'\nimport { Reader } from 'oer-utils'\nimport { Connection, BuildConnectionOpts } from './connection'\nimport * as cryptoHelper from './crypto'\n\nconst log = createLogger('ilp-protocol-stream:Pool')\n\ninterface ConnectionEvent {\n  (connection: Connection): void\n}\n\ntype ConnectionOptions = Omit<BuildConnectionOpts, 'sharedSecret'>\n\nexport class ServerConnectionPool {\n  private serverSecret: Buffer\n  private connectionOpts: ConnectionOptions\n  private onConnection: ConnectionEvent\n  private activeConnections: { [id: string]: Connection }\n  private pendingConnections: { [id: string]: Promise<Connection> }\n\n  constructor(\n    serverSecret: Buffer,\n    connectionOpts: ConnectionOptions,\n    onConnection: ConnectionEvent\n  ) {\n    this.serverSecret = serverSecret\n    this.connectionOpts = connectionOpts\n    this.onConnection = onConnection\n    this.activeConnections = {}\n    this.pendingConnections = {}\n  }\n\n  async close(): Promise<void> {\n    await Promise.all(\n      Object.keys(this.activeConnections).map((id: string) => this.activeConnections[id].end())\n    )\n  }\n\n  getServerAccount(): string {\n    return this.connectionOpts.sourceAccount\n  }\n\n  getAssetScale(): number {\n    return this.connectionOpts.assetScale\n  }\n\n  getAssetCode(): string {\n    return this.connectionOpts.assetCode\n  }\n\n  async getConnection(id: string, prepare: IlpPacket.IlpPrepare): Promise<Connection> {\n    const activeConnection = this.activeConnections[id]\n    if (activeConnection) return Promise.resolve(activeConnection)\n    const pendingConnection = this.pendingConnections[id]\n    if (pendingConnection) return pendingConnection\n\n    const connectionPromise = (async () => {\n      const token = Buffer.from(id, 'base64')\n      const sharedSecret = await this.getSharedSecret(token, prepare)\n      // If we get here, that means it was a token + sharedSecret we created\n      let connectionTag: string | undefined\n      let receiptNonce: Buffer | undefined\n      let receiptSecret: Buffer | undefined\n      const reader = new Reader(\n        cryptoHelper.decryptConnectionAddressToken(this.serverSecret, token)\n      )\n      reader.skipOctetString(cryptoHelper.TOKEN_NONCE_LENGTH)\n      if (reader.peekVarOctetString().length) {\n        connectionTag = reader.readVarOctetString().toString('ascii')\n      } else {\n        reader.skipVarOctetString()\n      }\n      switch (reader.peekVarOctetString().length) {\n        case 0:\n          reader.skipVarOctetString()\n          break\n        case 16:\n          receiptNonce = reader.readVarOctetString()\n          break\n        default:\n          throw new Error('receiptNonce must be 16 bytes')\n      }\n      switch (reader.peekVarOctetString().length) {\n        case 0:\n          reader.skipVarOctetString()\n          break\n        case 32:\n          receiptSecret = reader.readVarOctetString()\n          break\n        default:\n          throw new Error('receiptSecret must be 32 bytes')\n      }\n      const conn = await Connection.build({\n        ...this.connectionOpts,\n        sharedSecret,\n        connectionTag,\n        connectionId: id,\n        receiptNonce,\n        receiptSecret,\n      })\n      log.debug(\n        'got incoming packet for new connection: %s%s',\n        id,\n        connectionTag ? ' (connectionTag: ' + connectionTag + ')' : ''\n      )\n      try {\n        this.onConnection(conn)\n      } catch (err) {\n        log.error('error in connection event handler:', err)\n      }\n\n      conn.once('close', () => {\n        delete this.pendingConnections[id]\n        delete this.activeConnections[id]\n      })\n      return conn\n    })()\n\n    connectionPromise.catch(() => {\n      delete this.pendingConnections[id]\n    })\n\n    this.pendingConnections[id] = connectionPromise\n    const connection = await connectionPromise\n    this.activeConnections[id] = connection\n    delete this.pendingConnections[id]\n\n    // Wait for the next tick of the event loop before handling the prepare\n    await new Promise((resolve) => setTimeout(resolve))\n    return connection\n  }\n\n  private async getSharedSecret(token: Buffer, prepare: IlpPacket.IlpPrepare): Promise<Buffer> {\n    try {\n      const sharedSecret = cryptoHelper.generateSharedSecretFromToken(this.serverSecret, token)\n      // TODO just pass this into the connection?\n      const pskKey = await cryptoHelper.generatePskEncryptionKey(sharedSecret)\n      await cryptoHelper.decrypt(pskKey, prepare.data)\n      return sharedSecret\n    } catch (err) {\n      log.error(\n        'got prepare for an address and token that we did not generate: %s',\n        prepare.destination\n      )\n      throw err\n    }\n  }\n}\n"]}