{"version":3,"file":"connection.js","sourceRoot":"","sources":["../../src/connection.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events'\nimport createLogger, { Logger } from 'ilp-logger'\nimport { DataAndMoneyStream } from './stream'\nimport * as IlpPacket from 'ilp-packet'\nimport * as cryptoHelper from './crypto'\nimport {\n  Packet,\n  Frame,\n  StreamMoneyFrame,\n  StreamCloseFrame,\n  StreamDataFrame,\n  StreamMaxMoneyFrame,\n  FrameType,\n  IlpPacketType,\n  ConnectionNewAddressFrame,\n  ConnectionAssetDetailsFrame,\n  ErrorCode,\n  ConnectionCloseFrame,\n  ConnectionStreamIdBlockedFrame,\n  ConnectionMaxStreamIdFrame,\n  StreamMaxDataFrame,\n  StreamDataBlockedFrame,\n  StreamReceiptFrame,\n  ConnectionMaxDataFrame,\n  ConnectionDataBlockedFrame,\n  StreamMoneyBlockedFrame,\n} from './packet'\nimport { Reader } from 'oer-utils'\nimport { CongestionController } from './util/congestion'\nimport { Plugin } from './util/plugin-interface'\nimport {\n  maxLong,\n  minLong,\n  minLongs,\n  countDigits,\n  checkedAdd,\n  checkedSubtract,\n  multiplyDivideFloor,\n} from './util/long'\nimport Long from 'long'\nimport Rational from './util/rational'\nimport { createReceipt } from './util/receipt'\nimport { StoppableTimeout } from './util/stoppable-timeout'\nimport { v4 as uuid } from 'uuid'\n\nconst RETRY_DELAY_START = 100\nconst RETRY_DELAY_MAX = 43200000 // 12 hours should be long enough\nconst RETRY_DELAY_INCREASE_FACTOR = 1.5\nconst DEFAULT_PACKET_TIMEOUT = 30000\nconst DEFAULT_IDLE_TIMEOUT = 60000 // 1 minute\nconst MAX_DATA_SIZE = 32767\nconst DEFAULT_MAX_REMOTE_STREAMS = 10\nconst DEFAULT_MINIMUM_EXCHANGE_RATE_PRECISION = 3\nconst TEST_PACKET_MAX_ATTEMPTS = 15\n\nexport interface ConnectionOpts {\n  /** Token in the ILP address uniquely identifying this connection */\n  connectionId?: string\n  /** Ledger plugin (V2) */\n  plugin: Plugin\n  /** ILP Address of the remote entity */\n  destinationAccount?: string\n  /** ILP Address of the plugin */\n  sourceAccount?: string\n  /** Specifies how much worse than the initial test packet that the exchange rate is allowed to get before packets are rejected */\n  slippage?: number\n  /** Pad packets to the maximum size (data field of 32767 bytes). False by default */\n  enablePadding?: boolean\n  /** User-specified connection identifier that was passed into [`generateAddressAndSecret`]{@link Server#generateAddressAndSecret} */\n  connectionTag?: string\n  /** User-specified receipt nonce that was passed into [`generateAddressAndSecret`]{@link Server#generateAddressAndSecret} */\n  receiptNonce?: Buffer\n  /** User-specified receipt secret that was passed into [`generateAddressAndSecret`]{@link Server#generateAddressAndSecret} */\n  receiptSecret?: Buffer\n  /** Maximum number of streams the other entity can have open at once. Defaults to 10 */\n  maxRemoteStreams?: number\n  /** Number of bytes each connection can have in the buffer. Defaults to 65534 */\n  connectionBufferSize?: number\n  /** Minimum Precision to use when determining the exchange rate */\n  minExchangeRatePrecision?: number\n  /** Inactivity timeout (milliseconds) */\n  idleTimeout?: number\n  /**\n   * Fixed maximum packet amount. When set, the connection's maximum packet amount\n   * is the minimum of this setting and the path's discovered maximum amount.\n   */\n  maximumPacketAmount?: string\n  /**\n   * Fixed exchange rate. When set, the connection skips the packet volley step.\n   * Note that the minimum acceptable exchange rate is usually slightly lower than\n   * this (depending on the connection's slippage).\n   *\n   * This option should usually be used in concert with `ConnectionOpts.maximumPacketAmount`.\n   */\n  exchangeRate?: number\n  /**\n   * Returns the expiry to use for an ILP Prepare to the specified destination.\n   * When omitted, use a timeout of 30 seconds.\n   */\n  getExpiry?: (destination: string) => Date\n  /**\n   * Callback for the consumer to perform accounting and choose to fulfill an incoming ILP Prepare,\n   * given the amount received, a unique identifier for the packet, and `connectionTag`.\n   *\n   * If the returned Promise is resolved, the ILP Prepare will be fulfilled; if it is rejected,\n   * the ILP Prepare will be rejected. The ILP Fulfill will be immediately sent back after\n   * the Promise is resolved.\n   *\n   * Note: a misbehaving sender can trigger duplicate packetIds, which should be ignored and rejected.\n   */\n  shouldFulfill?: (packetAmount: Long, packetId: Buffer, connectionTag?: string) => Promise<void>\n}\n\nexport interface BuildConnectionOpts extends ConnectionOpts {\n  sourceAccount: string\n  assetCode: string\n  assetScale: number\n  isServer: boolean\n  /** Shared secret generated by the server with [`generateAddressAndSecret`]{@link Server#generateAddressAndSecret} */\n  sharedSecret: Buffer\n}\n\ninterface NewConnectionOpts extends BuildConnectionOpts {\n  pskKey: Buffer\n  fulfillmentKey: Buffer\n}\n\nexport class ConnectionError extends Error {\n  streamErrorCode: ErrorCode\n\n  constructor(message: string, streamErrorCode?: ErrorCode) {\n    super(message)\n    this.streamErrorCode = streamErrorCode || ErrorCode.InternalError\n  }\n}\n\nexport class IlpRejectionError extends Error {\n  ilpReject: IlpPacket.IlpReject\n\n  constructor(message: string, ilpReject: IlpPacket.IlpReject) {\n    super(message)\n\n    this.ilpReject = ilpReject\n  }\n}\n\nenum RemoteState {\n  Init,\n  Connected,\n  Closed,\n}\n\nexport interface PacketError {\n  sourceAmount: Long\n  code: string\n}\n\nexport interface TestVolleyResult {\n  maxDigits: number\n  exchangeRate: Rational\n  maxPacketAmounts: Long[]\n  packetErrors: PacketError[]\n}\n\nfunction defaultGetExpiry(): Date {\n  return new Date(Date.now() + DEFAULT_PACKET_TIMEOUT)\n}\n\n/**\n * Class representing the connection between a [`Client`]{@link createConnection} and a [`Server`]{@link Server}.\n * A single connection can be used to send or receive on [Streams]{@link DataAndMoneyStream}.\n *\n * Streams are created using the [`createStream`]{@link createStream} method.\n * The `'stream'` event will be emitted whenever a new incoming stream is opened by the other party.\n */\nexport class Connection extends EventEmitter {\n  /** Application identifier for a certain connection */\n  readonly connectionTag?: string\n  protected readonly _receiptNonce?: Buffer\n  protected readonly _receiptSecret?: Buffer\n\n  protected connectionId: string\n  protected plugin: Plugin\n  protected _sourceAccount: string\n  protected _sourceAssetCode: string\n  protected _sourceAssetScale: number\n  protected _destinationAccount?: string\n  protected _destinationAssetCode?: string\n  protected _destinationAssetScale?: number\n  protected sharedSecret: Buffer\n  protected _pskKey: Buffer\n  protected _fulfillmentKey: Buffer\n  protected isServer: boolean\n  protected slippage: Rational\n  protected allowableReceiveExtra: Rational\n  protected enablePadding: boolean\n  protected maxBufferedData: number\n\n  protected idleTimeout: number\n  protected lastActive: Date\n  protected idleTimer?: NodeJS.Timer\n  protected rateRetryTimer: StoppableTimeout = new StoppableTimeout()\n\n  protected nextPacketSequence: number\n  protected streams: Map<number, DataAndMoneyStream>\n  protected closedStreams: Set<number>\n  protected nextStreamId: number\n  protected maxStreamId: number\n  protected log: Logger\n  protected sending: boolean\n  protected looping = false // whether there is a running send-loop\n  protected congestion: CongestionController\n  protected minExchangeRatePrecision: number\n  protected connected: boolean\n  // Set to `true`:\n  // - Until `'connect'` event.\n  // - When a `ConnectionCloseFrame` is received.\n  // - When `end()` is called, but before sending the `ConnectionCloseFrame` to remote.\n  protected closed: boolean\n  // Set to `true` when either `end()` or `destroy()` has finished.\n  protected done = false\n  protected exchangeRate?: Rational\n  protected retryDelay: number\n  protected queuedFrames: Frame[]\n\n  protected remoteState: RemoteState = RemoteState.Init\n  protected remoteMaxStreamId: number\n  protected remoteKnowsOurAccount: boolean\n\n  // TODO use longs for byte offsets\n  protected remoteMaxOffset: number\n  protected _incomingHold: Long\n  protected _totalReceived: Long\n  protected _totalSent: Long\n  protected _totalDelivered: Long\n  protected _lastPacketExchangeRate: Rational\n  protected getExpiry: (destination: string) => Date\n  protected shouldFulfill?: (\n    packetAmount: Long,\n    packetId: Buffer,\n    connectionTag?: string\n  ) => Promise<void>\n\n  constructor(opts: NewConnectionOpts) {\n    super()\n\n    // Use the same connectionId for logging on both client & server\n    const lastAddressSegment = opts.destinationAccount\n      ? opts.destinationAccount.split('.').slice(-1)[0]\n      : undefined\n    this.connectionId = (opts.connectionId || lastAddressSegment || uuid())\n      .replace(/[-_]/g, '')\n      .slice(0, 8)\n\n    this.plugin = opts.plugin\n    this._sourceAccount = opts.sourceAccount\n    this._sourceAssetCode = opts.assetCode\n    this._sourceAssetScale = opts.assetScale\n    this._destinationAccount = opts.destinationAccount\n    this.sharedSecret = opts.sharedSecret\n    this.isServer = opts.isServer\n    this._pskKey = opts.pskKey\n    this._fulfillmentKey = opts.fulfillmentKey\n    this.slippage = Rational.fromNumber(opts.slippage === undefined ? 0.01 : opts.slippage, true)\n    if (this.slippage.greaterThanOne()) {\n      throw new Error('slippage must be less than one')\n    }\n    this.allowableReceiveExtra = Rational.fromNumber(1.01, true)\n    this.enablePadding = !!opts.enablePadding\n    this.connectionTag = opts.connectionTag\n    if (!opts.receiptNonce !== !opts.receiptSecret) {\n      throw new Error('receiptNonce and receiptSecret must accompany each other')\n    }\n    this._receiptNonce = opts.receiptNonce\n    this._receiptSecret = opts.receiptSecret\n    this.maxStreamId = 2 * (opts.maxRemoteStreams || DEFAULT_MAX_REMOTE_STREAMS)\n    this.maxBufferedData = opts.connectionBufferSize || MAX_DATA_SIZE * 2\n    this.minExchangeRatePrecision =\n      opts.minExchangeRatePrecision || DEFAULT_MINIMUM_EXCHANGE_RATE_PRECISION\n    this.exchangeRate =\n      opts.exchangeRate === undefined ? undefined : Rational.fromNumber(opts.exchangeRate, true)\n    this.getExpiry = opts.getExpiry || defaultGetExpiry\n    this.shouldFulfill = opts.shouldFulfill\n    this.idleTimeout = opts.idleTimeout || DEFAULT_IDLE_TIMEOUT\n    this.lastActive = new Date()\n\n    this.nextPacketSequence = 1\n    // TODO should streams be a Map or just an object?\n    this.streams = new Map()\n    this.closedStreams = new Set()\n    this.nextStreamId = this.isServer ? 2 : 1\n    this.log = createLogger(\n      `ilp-protocol-stream:${this.isServer ? 'Server' : 'Client'}:Connection:${this.connectionId}`\n    )\n    this.sending = false\n    this.connected = false\n    this.closed = true\n    this.queuedFrames = []\n\n    this.congestion = new CongestionController({\n      maximumPacketAmount:\n        opts.maximumPacketAmount === undefined\n          ? undefined\n          : Long.fromString(opts.maximumPacketAmount, true),\n    })\n    this.retryDelay = RETRY_DELAY_START\n\n    this.remoteKnowsOurAccount = this.isServer\n    this.remoteMaxStreamId = DEFAULT_MAX_REMOTE_STREAMS * 2\n\n    this.remoteMaxOffset = this.maxBufferedData\n\n    this._incomingHold = Long.UZERO\n    this._totalReceived = Long.UZERO\n    this._totalSent = Long.UZERO\n    this._totalDelivered = Long.UZERO\n    this._lastPacketExchangeRate = Rational.UZERO\n    this.once('connect', () => this.startIdleTimer())\n  }\n\n  /**\n   * @private\n   */\n  static async build(opts: BuildConnectionOpts): Promise<Connection> {\n    const pskKey = await cryptoHelper.generatePskEncryptionKey(opts.sharedSecret)\n    const fulfillmentKey = await cryptoHelper.generateFulfillmentKey(opts.sharedSecret)\n    return new Connection(Object.assign({ pskKey, fulfillmentKey }, opts))\n  }\n\n  /**\n   * New incoming stream event\n   * @event stream\n   * @type {DataAndMoneyStream}\n   */\n\n  /**\n   * Start sending or receiving.\n   * @fires stream\n   */\n  async connect(): Promise<void> {\n    if (!this.closed) {\n      return Promise.resolve()\n    }\n    this.startSendLoop()\n    await new Promise<void>((resolve, reject) => {\n      const connectHandler = () => {\n        cleanup()\n        resolve()\n      }\n      const closeHandler = () => {\n        cleanup()\n        this.stopTimers()\n        reject(new Error('Connection was closed before it was connected'))\n      }\n      const errorHandler = (error?: Error) => {\n        cleanup()\n        this.stopTimers()\n        reject(new Error(`Error connecting${error ? ': ' + error.message : ''}`))\n      }\n      this.once('connect', connectHandler)\n      this.once('error', errorHandler)\n      this.once('close', closeHandler)\n      this.once('end', closeHandler)\n\n      const cleanup = () => {\n        this.removeListener('connect', connectHandler)\n        this.removeListener('error', errorHandler)\n        this.removeListener('close', closeHandler)\n        this.removeListener('end', closeHandler)\n      }\n    })\n    this.closed = false\n  }\n\n  /**\n   * Close the connection when all streams have finished sending their money and data\n   */\n  // TODO should this be sync or async?\n  async end(): Promise<void> {\n    this.log.info('closing connection')\n    // Create Promises on each stream that resolve on the 'end' event so\n    // we can wait for them all to be completed before closing the connection\n    const streamEndPromises: Promise<void>[] = []\n    for (const [, stream] of this.streams) {\n      if (stream.isOpen()) {\n        streamEndPromises.push(\n          new Promise((resolve) => {\n            stream.on('end', resolve)\n          })\n        )\n        stream.end()\n      }\n    }\n\n    await new Promise((resolve, reject) => {\n      this.once('_send_loop_finished', resolve)\n      this.once('error', reject)\n\n      this.startSendLoop()\n    })\n    // Wait for the send loop to finish & all the streams to end\n    // before marking the connection as closed so the streams\n    // can finish sending data or money.\n    await Promise.all(streamEndPromises)\n\n    this.closed = true\n    await this.sendConnectionClose()\n    this.safeEmit('end')\n    this.safeEmit('close')\n    this.stopTimers()\n  }\n\n  /**\n   * Immediately close the connection and all streams.\n   *\n   * This function must *never* return a rejection, since `startSendLoop` is run\n   * as a floating promise and returns `destroy()` on errors, so the rejection\n   * would be unhandled.\n   */\n  // TODO should this be sync or async?\n  async destroy(err?: Error): Promise<void> {\n    this.log.error('destroying connection with error:', err)\n    // Don't destroy the connection (most importantly: don't emit \"close\" & \"error\"\n    // if the connection has already done so, since it will confuse clients.\n    if (this.done) return\n\n    if (err) {\n      this.safeEmit('error', err)\n    }\n    // Create Promises on each stream that resolve on the 'close' event so\n    // we can wait for them all to be completed before closing the connection\n    const streamClosePromises: Promise<void>[] = []\n    for (const [, stream] of this.streams) {\n      streamClosePromises.push(\n        new Promise((resolve) => {\n          stream.on('close', resolve)\n        })\n      )\n      // TODO should we pass the error to each stream?\n      stream.destroy()\n    }\n    // Send an error to ensure that the other side doesn't get a NoError.\n    await this.sendConnectionClose(\n      err || new ConnectionError('Connection destroyed', ErrorCode.ApplicationError)\n    )\n    // wait for all the streams to be closed before emitting the connection 'close'\n    await Promise.all(streamClosePromises)\n    this.safeEmit('close')\n    this.stopTimers()\n  }\n\n  /**\n   * Returns a new bidirectional [`DataAndMoneyStream`]{@link DataAndMoneyStream}\n   */\n  createStream(): DataAndMoneyStream {\n    // Make sure we don't open more streams than the remote will allow\n    if (this.remoteMaxStreamId < this.nextStreamId) {\n      this.log.debug(\n        'cannot create another stream. nextStreamId: %d, remote maxStreamId: %d',\n        this.nextStreamId,\n        this.remoteMaxStreamId\n      )\n      this.queuedFrames.push(new ConnectionStreamIdBlockedFrame(this.nextStreamId))\n      throw new Error(\n        `Creating another stream would exceed the remote connection's maximum number of open streams`\n      )\n    }\n\n    // TODO should this inform the other side?\n    const stream = new DataAndMoneyStream({\n      id: this.nextStreamId,\n      isServer: this.isServer,\n      connectionId: this.connectionId,\n    })\n    this.streams.set(this.nextStreamId, stream)\n    this.log.debug('created stream: %d', this.nextStreamId)\n    this.nextStreamId += 2\n\n    stream.on('_maybe_start_send_loop', this.startSendLoop.bind(this))\n    stream.once('close', () => this.removeStreamRecord(stream))\n\n    return stream\n  }\n\n  /**\n   * ILP Address of the remote party to this connection.\n   */\n  get destinationAccount(): string | undefined {\n    return this._destinationAccount\n  }\n\n  /**\n   * Scale of the asset used by the remote party to this connection\n   */\n  get destinationAssetScale(): number | undefined {\n    return this._destinationAssetScale\n  }\n\n  /**\n   * Code of the asset used by the remote party to this connection\n   */\n  get destinationAssetCode(): string | undefined {\n    return this._destinationAssetCode\n  }\n\n  /**\n   * ILP Address of the plugin passed to this connection.\n   */\n  get sourceAccount(): string {\n    return this._sourceAccount\n  }\n\n  /**\n   * Scale of the asset used by the plugin passed to this connection\n   */\n  get sourceAssetScale(): number {\n    return this._sourceAssetScale\n  }\n\n  /**\n   * Code of the asset used by the plugin passed to this connection\n   */\n  get sourceAssetCode(): string {\n    return this._sourceAssetCode\n  }\n\n  /**\n   * Connections minimum exchange rate with slippage included, if not set '0' is returned.\n   */\n  get minimumAcceptableExchangeRate(): string {\n    if (this.exchangeRate) {\n      const minimumExchangeWithSlippage = this.exchangeRate.multiplyByRational(\n        this.slippage.complement()\n      )\n      return minimumExchangeWithSlippage.toString()\n    }\n    return '0'\n  }\n\n  /**\n   * Calculates the last exchange rate based on last packet successfully sent.\n   */\n  get lastPacketExchangeRate(): string {\n    return this._lastPacketExchangeRate.toString()\n  }\n\n  /**\n   * Total delivered so far, denominated in the connection plugin's units.\n   */\n  get totalDelivered(): string {\n    return this._totalDelivered.toString()\n  }\n\n  /**\n   * Total sent so far, denominated in the connection plugin's units.\n   */\n  get totalSent(): string {\n    return this._totalSent.toString()\n  }\n\n  /**\n   * Total received so far by the local side, denominated in the connection plugin's units.\n   */\n  get totalReceived(): string {\n    return this._totalReceived.toString()\n  }\n\n  /**\n   * (Internal) Handle incoming ILP Prepare packets.\n   * This will automatically fulfill all valid and expected Prepare packets, or\n   * defer to custom application logic using the `shouldFulfill` callback, if provided.\n   * It passes the incoming money and/or data to the relevant streams.\n   * @private\n   */\n  async handlePrepare(prepare: IlpPacket.IlpPrepare): Promise<IlpPacket.IlpFulfill> {\n    // Parse packet\n    let requestPacket: Packet\n    try {\n      requestPacket = await Packet.decryptAndDeserialize(this._pskKey, prepare.data)\n    } catch (err) {\n      this.log.error('error parsing frames:', err)\n      throw new IlpPacket.Errors.UnexpectedPaymentError('')\n    }\n    this.log.trace('handling packet:', JSON.stringify(requestPacket))\n\n    if (requestPacket.ilpPacketType.valueOf() !== IlpPacket.Type.TYPE_ILP_PREPARE) {\n      this.log.error(\n        'prepare packet contains a frame that says it should be something other than a prepare: %d',\n        requestPacket.ilpPacketType\n      )\n      throw new IlpPacket.Errors.UnexpectedPaymentError('')\n    }\n    this.bumpIdle()\n\n    let responseFrames: Frame[] = []\n\n    // Tell peer how much data connection can receive\n    responseFrames.push(new ConnectionMaxDataFrame(this.getIncomingOffsets().maxAcceptable))\n\n    const constructFinalApplicationError = async () => {\n      responseFrames = responseFrames.concat(this.queuedFrames)\n      this.queuedFrames = []\n      const responsePacket = new Packet(\n        requestPacket.sequence,\n        IlpPacketType.Reject,\n        prepare.amount,\n        responseFrames\n      )\n      this.log.trace('rejecting packet %s: %j', requestPacket.sequence, responsePacket)\n      return new IlpPacket.Errors.FinalApplicationError(\n        '',\n        await responsePacket.serializeAndEncrypt(\n          this._pskKey,\n          this.enablePadding ? MAX_DATA_SIZE : undefined\n        )\n      )\n    }\n\n    // Handle new streams\n    for (const frame of requestPacket.frames) {\n      if (\n        frame.type === FrameType.StreamMoney ||\n        frame.type === FrameType.StreamData ||\n        // TODO should frames that set the max values open the stream?\n        frame.type === FrameType.StreamMaxMoney ||\n        frame.type === FrameType.StreamMaxData\n      ) {\n        const streamId = frame.streamId.toNumber()\n\n        // Check if the stream was already closed\n        if (this.closedStreams.has(streamId)) {\n          this.log.trace('got packet with frame for stream %d, which was already closed', streamId)\n\n          // Don't bother sending an error frame back unless they've actually sent money or data\n          if (frame.type !== FrameType.StreamMoney && frame.type !== FrameType.StreamData) {\n            continue\n          }\n\n          // Respond with a StreamClose frame (unless there is already one queued)\n          const testStreamClose = (frame: Frame): boolean => {\n            return frame.type === FrameType.StreamClose && frame.streamId.equals(streamId)\n          }\n          const includesStreamClose =\n            responseFrames.find(testStreamClose) || this.queuedFrames.find(testStreamClose)\n          if (!includesStreamClose) {\n            responseFrames.push(\n              new StreamCloseFrame(streamId, ErrorCode.StreamStateError, 'Stream is already closed')\n            )\n          }\n          throw await constructFinalApplicationError()\n        }\n\n        try {\n          // Note this will throw if the stream was already closed\n          this.handleNewStream(frame.streamId.toNumber())\n        } catch (err) {\n          this.log.debug('error handling new stream %s: %s', frame.streamId, err)\n          throw await constructFinalApplicationError()\n        }\n      }\n    }\n\n    // TODO don't throw errors in expected cases -- they are slower than just returning a value\n    try {\n      this.handleControlFrames(requestPacket.frames)\n    } catch (err) {\n      this.log.debug('error handling frames:', err)\n      throw await constructFinalApplicationError()\n    }\n\n    // TODO keep a running total of the offsets so we don't need to recalculate each time\n    const incomingOffsets = this.getIncomingOffsets()\n    if (incomingOffsets.max > incomingOffsets.maxAcceptable) {\n      this.destroy(\n        new ConnectionError(\n          `Exceeded flow control limits. Max connection byte offset: ${incomingOffsets.maxAcceptable}, received: ${incomingOffsets.max}`,\n          ErrorCode.FlowControlError\n        )\n      )\n      throw await constructFinalApplicationError()\n    }\n\n    const incomingAmount = Long.fromString(prepare.amount, true)\n    if (requestPacket.prepareAmount.greaterThan(incomingAmount)) {\n      this.log.debug(\n        'received less than minimum destination amount. actual: %s, expected: %s',\n        prepare.amount,\n        requestPacket.prepareAmount\n      )\n      throw await constructFinalApplicationError()\n    }\n\n    // Ensure we can generate correct fulfillment\n    const fulfillment = await cryptoHelper.generateFulfillment(this._fulfillmentKey, prepare.data)\n    const generatedCondition = await cryptoHelper.hash(fulfillment)\n    if (!generatedCondition.equals(prepare.executionCondition)) {\n      this.log.debug(\n        'got unfulfillable prepare for amount: %s. generated condition: %h, prepare condition: %h',\n        prepare.amount,\n        generatedCondition,\n        prepare.executionCondition\n      )\n      throw await constructFinalApplicationError()\n    }\n\n    // Determine amount to receive on each frame\n    const amountsToReceive: { stream: DataAndMoneyStream; amount: Long }[] = []\n    const totalMoneyShares = requestPacket.frames.reduce((sum: Long, frame: Frame) => {\n      if (frame instanceof StreamMoneyFrame) {\n        const result = checkedAdd(sum, frame.shares)\n        if (result.overflow) throw new Error('Total shares exceeded MaxUint64')\n        return result.sum\n      }\n      return sum\n    }, Long.UZERO)\n    for (const frame of requestPacket.frames) {\n      if (!(frame instanceof StreamMoneyFrame)) {\n        continue\n      }\n      const streamId = frame.streamId.toNumber()\n      // TODO make sure we don't lose any because of rounding issues\n      const streamAmount = multiplyDivideFloor(incomingAmount, frame.shares, totalMoneyShares)\n      const stream = this.streams.get(streamId)\n      if (!stream) {\n        this.log.debug(\"peer sent money for stream whose id we don't recognize: %d\", streamId)\n        responseFrames.push(\n          new StreamCloseFrame(streamId, ErrorCode.StreamIdError, 'Unknown stream ID')\n        )\n\n        throw await constructFinalApplicationError()\n      }\n      amountsToReceive.push({\n        stream,\n        amount: streamAmount,\n      })\n\n      // Ensure that this amount isn't more than the stream can receive\n      const maxStreamCanReceive = this.allowableReceiveExtra.multiplyByLongCeil(\n        stream._getAmountStreamCanReceive()\n      )\n      if (maxStreamCanReceive.lessThan(streamAmount)) {\n        // TODO should this be distributed to other streams if it can be?\n        this.log.debug(\n          'peer sent too much for stream: %d. got: %s, max receivable: %s',\n          streamId,\n          streamAmount,\n          maxStreamCanReceive\n        )\n        // Tell peer how much the streams they sent for can receive\n        responseFrames.push(\n          new StreamMaxMoneyFrame(streamId, stream.receiveMax, stream.totalReceived)\n        )\n\n        // TODO include error frame\n        throw await constructFinalApplicationError()\n      }\n\n      // Reject the packet if any of the streams is already closed\n      if (!stream.isOpen()) {\n        this.log.debug('peer sent money for stream that was already closed: %d', streamId)\n        responseFrames.push(\n          new StreamCloseFrame(streamId, ErrorCode.StreamStateError, 'Stream is already closed')\n        )\n\n        throw await constructFinalApplicationError()\n      }\n    }\n\n    this.addIncomingHold(incomingAmount)\n\n    // Allow consumer to choose to fulfill each packet and/or perform other logic before fulfilling\n    if (this.shouldFulfill && incomingAmount.greaterThan(0)) {\n      const packetId = await cryptoHelper.generateIncomingPacketId(\n        this.sharedSecret,\n        requestPacket.sequence\n      )\n      await this.shouldFulfill(incomingAmount, packetId, this.connectionTag).catch(async (err) => {\n        this.removeIncomingHold(incomingAmount)\n        this.log.debug('application declined to fulfill packet %s:', requestPacket.sequence, err)\n        throw await constructFinalApplicationError()\n      })\n    }\n\n    // Add incoming amounts to each stream\n    const totalsReceived: Map<number, string> = new Map()\n    for (const { stream, amount } of amountsToReceive) {\n      stream._addToIncoming(amount, prepare)\n      totalsReceived.set(stream.id, stream.totalReceived)\n    }\n\n    // Tell peer about closed streams and how much each stream can receive\n    if (!this.closed && this.remoteState !== RemoteState.Closed) {\n      for (const [, stream] of this.streams) {\n        if (!stream.isOpen() && !stream._remoteClosed) {\n          this.log.trace('telling other side that stream %d is closed', stream.id)\n          if (stream._errorMessage) {\n            responseFrames.push(\n              new StreamCloseFrame(stream.id, ErrorCode.ApplicationError, stream._errorMessage)\n            )\n          } else {\n            responseFrames.push(new StreamCloseFrame(stream.id, ErrorCode.NoError, ''))\n          }\n          // TODO confirm that they get this\n          stream._remoteClosed = true\n        } else {\n          this.log.trace(\n            'telling other side that stream %d can receive %s',\n            stream.id,\n            stream.receiveMax\n          )\n          responseFrames.push(\n            new StreamMaxMoneyFrame(stream.id, stream.receiveMax, stream.totalReceived)\n          )\n\n          // TODO only send these frames when we need to\n          responseFrames.push(\n            new StreamMaxDataFrame(stream.id, stream._getIncomingOffsets().maxAcceptable)\n          )\n        }\n      }\n    }\n\n    // Add receipt frame(s)\n    if (this._receiptNonce && this._receiptSecret) {\n      for (const [streamId, totalReceived] of totalsReceived) {\n        responseFrames.push(\n          new StreamReceiptFrame(\n            streamId,\n            createReceipt({\n              nonce: this._receiptNonce,\n              streamId,\n              totalReceived,\n              secret: this._receiptSecret,\n            })\n          )\n        )\n      }\n    }\n\n    // TODO make sure the queued frames aren't too big\n    responseFrames = responseFrames.concat(this.queuedFrames)\n    this.queuedFrames = []\n\n    // Return fulfillment and response packet\n    const responsePacket = new Packet(\n      requestPacket.sequence,\n      IlpPacketType.Fulfill,\n      incomingAmount,\n      responseFrames\n    )\n    this.removeIncomingHold(incomingAmount)\n    this.addTotalReceived(incomingAmount)\n    this.log.trace(\n      'fulfilling prepare with fulfillment: %h and response packet: %j',\n      fulfillment,\n      responsePacket\n    )\n    return {\n      fulfillment,\n      data: await responsePacket.serializeAndEncrypt(\n        this._pskKey,\n        this.enablePadding ? MAX_DATA_SIZE : undefined\n      ),\n    }\n  }\n\n  /**\n   * Parse the frames from the incoming packet and apply all effects\n   * except for passing money to the streams\n   */\n  protected handleControlFrames(frames: Frame[]): void {\n    for (const frame of frames) {\n      let stream\n      switch (frame.type) {\n        case FrameType.ConnectionNewAddress: {\n          this.log.trace('peer notified us of their account: %s', frame.sourceAccount)\n\n          // Tell the other side our max stream id and asset details\n          this.queuedFrames.push(\n            new ConnectionMaxStreamIdFrame(this.maxStreamId),\n            new ConnectionAssetDetailsFrame(this.sourceAssetCode, this.sourceAssetScale)\n          )\n\n          const firstConnection = this._destinationAccount === undefined\n          this._destinationAccount = frame.sourceAccount\n          if (firstConnection) {\n            this.closed = false\n            this.log.info('connected')\n            this.safeEmit('connect')\n          }\n          // TODO reset the exchange rate and send a test packet to make sure they haven't spoofed the address\n          break\n        }\n        case FrameType.ConnectionAssetDetails:\n          this.log.trace(\n            'peer notified us of their asset details: code=%s, scale=%d',\n            frame.sourceAssetCode,\n            frame.sourceAssetScale\n          )\n          this._destinationAssetCode = frame.sourceAssetCode\n          this._destinationAssetScale = frame.sourceAssetScale\n          break\n        case FrameType.ConnectionClose:\n          // TODO end the connection in some other way\n          this.sending = false\n          this.closed = true\n          this.remoteState = RemoteState.Closed\n          if (frame.errorCode === ErrorCode.NoError) {\n            this.log.info('remote closed connection')\n            this.end().catch((err) => {\n              this.log.warn('close failed with error=%s', err)\n              return this.destroy()\n            })\n          } else {\n            this.log.error(\n              'remote connection error. code: %s, message: %s',\n              ErrorCode[frame.errorCode],\n              frame.errorMessage\n            )\n            this.destroy(\n              new Error(\n                `Remote connection error. Code: ${ErrorCode[frame.errorCode]}, message: ${\n                  frame.errorMessage\n                }`\n              )\n            )\n          }\n          break\n        case FrameType.ConnectionMaxData: {\n          const outgoingOffsets = this.getOutgoingOffsets()\n          this.log.trace(\n            \"remote connection max byte offset is: %s, we've sent: %d, we want to send up to: %d\",\n            frame.maxOffset,\n            outgoingOffsets.currentOffset,\n            outgoingOffsets.maxOffset\n          )\n          if (frame.maxOffset.notEquals(this.maxBufferedData)) {\n            this.remoteMaxOffset = Math.max(frame.maxOffset.toNumber(), this.remoteMaxOffset)\n          } else {\n            // We assumed their size was 64kb but it turned out to be less\n            this.remoteMaxOffset = frame.maxOffset.toNumber()\n          }\n          break\n        }\n        case FrameType.ConnectionDataBlocked:\n          this.log.trace(\n            'remote wants to send more data but we are blocking them. current max incoming offset: %d, remote max offset: %s',\n            this.getIncomingOffsets(),\n            frame.maxOffset\n          )\n          break\n        case FrameType.ConnectionMaxStreamId:\n          // TODO make sure the number isn't lowered\n          this.log.trace('remote set max stream id to %s', frame.maxStreamId)\n          this.remoteMaxStreamId = frame.maxStreamId.toNumber()\n          break\n        case FrameType.ConnectionStreamIdBlocked:\n          this.log.trace('remote wants to open more streams but we are blocking them')\n          break\n        case FrameType.StreamClose:\n          this.handleStreamClose(frame)\n          break\n        case FrameType.StreamMaxMoney:\n          this.log.trace(\n            'peer told us that stream %s can receive up to: %s and has received: %s so far',\n            frame.streamId,\n            frame.receiveMax,\n            frame.totalReceived\n          )\n          stream = this.streams.get(frame.streamId.toNumber())\n          if (!stream) {\n            break\n          }\n          stream._remoteReceived = maxLong(stream._remoteReceived, frame.totalReceived)\n          if (stream._remoteReceiveMax.notEquals(Long.MAX_UNSIGNED_VALUE)) {\n            stream._remoteReceiveMax = maxLong(stream._remoteReceiveMax, frame.receiveMax)\n          } else {\n            stream._remoteReceiveMax = frame.receiveMax\n          }\n          if (\n            stream._remoteReceiveMax.greaterThan(stream._remoteReceived) &&\n            stream._getAmountAvailableToSend().greaterThan(0)\n          ) {\n            this.startSendLoop()\n          }\n          break\n        case FrameType.StreamMoneyBlocked:\n          this.log.debug(\n            'peer told us that they want to send more money on stream %s but we are blocking them. they have sent: %s so far and want to send: %s',\n            frame.streamId,\n            frame.totalSent,\n            frame.sendMax\n          )\n          break\n        case FrameType.StreamData: {\n          this.log.trace('got data for stream %s', frame.streamId)\n\n          stream = this.streams.get(frame.streamId.toNumber())\n          if (!stream) {\n            break\n          }\n          stream._pushIncomingData(frame.data, frame.offset.toNumber())\n\n          // Make sure the peer hasn't exceeded the flow control limits\n          const incomingOffsets = stream._getIncomingOffsets()\n          if (incomingOffsets.max > incomingOffsets.maxAcceptable) {\n            this.destroy(\n              new ConnectionError(\n                `Exceeded flow control limits. Stream ${stream.id} can accept up to offset: ${incomingOffsets.maxAcceptable} but got bytes up to offset: ${incomingOffsets.max}`,\n                ErrorCode.FlowControlError\n              )\n            )\n          }\n          break\n        }\n        case FrameType.StreamMaxData: {\n          stream = this.streams.get(frame.streamId.toNumber())\n          if (!stream) {\n            break\n          }\n          const oldOffset = stream._remoteMaxOffset\n          const newOffset = frame.maxOffset.toNumber()\n          if (newOffset > oldOffset) {\n            this.log.trace(\n              \"peer told us that stream %s can receive up to byte offset: %s (we've sent up to offset: %d)\",\n              frame.streamId,\n              frame.maxOffset,\n              stream._getOutgoingOffsets().current\n            )\n            stream._remoteMaxOffset = newOffset\n            this.startSendLoop()\n          } else {\n            this.log.trace(\n              'peer told us that stream %s can receive up to byte offset: %d; ignoring new offset: %d',\n              frame.streamId,\n              oldOffset,\n              newOffset\n            )\n          }\n          break\n        }\n        case FrameType.StreamDataBlocked:\n          stream = this.streams.get(frame.streamId.toNumber())\n          if (!stream) {\n            break\n          }\n          this.log.debug(\n            'peer told us that stream %s is blocked. they want to send up to offset: %s, but we are only allowing up to: %d',\n            frame.streamId,\n            frame.maxOffset,\n            stream._getIncomingOffsets().maxAcceptable\n          )\n          break\n        default:\n          continue\n      }\n    }\n  }\n\n  /**\n   * Ensure that the new stream is valid and does not exceed our limits\n   * and if it looks good, emit the 'stream' event\n   */\n  protected handleNewStream(streamId: number): void {\n    if (this.streams.has(streamId) || this.closedStreams.has(streamId)) {\n      return\n    }\n\n    // Validate stream ID\n    if (this.isServer && streamId % 2 === 0) {\n      this.log.error('got invalid stream ID %d from peer (should be odd)', streamId)\n      this.queuedFrames.push(\n        new ConnectionCloseFrame(\n          ErrorCode.ProtocolViolation,\n          `Invalid Stream ID: ${streamId}. Client-initiated streams must have odd-numbered IDs`\n        )\n      )\n      // TODO this should probably call this.destroy\n      const err = new Error(\n        `Invalid Stream ID: ${streamId}. Client-initiated streams must have odd-numbered IDs`\n      )\n      this.safeEmit('error', err)\n      throw err\n    } else if (!this.isServer && streamId % 2 === 1) {\n      this.log.error('got invalid stream ID %d from peer (should be even)', streamId)\n      this.queuedFrames.push(\n        new ConnectionCloseFrame(\n          ErrorCode.ProtocolViolation,\n          `Invalid Stream ID: ${streamId}. Server-initiated streams must have even-numbered IDs`\n        )\n      )\n      const err = new Error(\n        `Invalid Stream ID: ${streamId}. Server-initiated streams must have even-numbered IDs`\n      )\n      this.safeEmit('error', err)\n      throw err\n    }\n\n    // Make sure there aren't too many open streams\n    if (streamId > this.maxStreamId) {\n      this.log.debug(\n        'peer opened too many streams. got stream: %d, but max stream id is: %d. closing connection',\n        streamId,\n        this.maxStreamId\n      )\n      this.queuedFrames.push(\n        new ConnectionCloseFrame(\n          ErrorCode.StreamIdError,\n          `Maximum number of open streams exceeded. Got stream: ${streamId}, current max stream ID: ${this.maxStreamId}`\n        )\n      )\n      const err = new Error(\n        `Maximum number of open streams exceeded. Got stream: ${streamId}, current max stream ID: ${this.maxStreamId}`\n      )\n      this.safeEmit('error', err)\n      throw err\n    }\n\n    // Let the other side know if they're getting close to the number of streams\n    if (this.maxStreamId * 0.75 < streamId) {\n      this.log.trace('informing peer that our max stream id is: %d', this.maxStreamId)\n      this.queuedFrames.push(new ConnectionMaxStreamIdFrame(this.maxStreamId))\n    }\n\n    this.log.info('got new stream: %d', streamId)\n    const stream = new DataAndMoneyStream({\n      id: streamId,\n      isServer: this.isServer,\n      connectionId: this.connectionId,\n    })\n    this.streams.set(streamId, stream)\n\n    stream.on('_maybe_start_send_loop', () => this.startSendLoop())\n    stream.once('close', () => this.removeStreamRecord(stream))\n\n    this.safeEmit('stream', stream)\n  }\n\n  /**\n   * Mark the stream as closed\n   */\n  protected handleStreamClose(frame: StreamCloseFrame) {\n    const streamId = frame.streamId.toNumber()\n    const stream = this.streams.get(streamId)\n    if (!stream) {\n      this.log.error(\n        \"remote error on stream %d, but we don't have a record of that stream\",\n        streamId\n      )\n      return\n    }\n\n    if (!stream.isOpen() || stream._remoteSentEnd) {\n      return\n    }\n\n    this.log.error(\n      'peer closed stream %d with error code: %s and message: %s',\n      stream.id,\n      ErrorCode[frame.errorCode],\n      frame.errorMessage\n    )\n    // TODO should we confirm with the other side that we closed it?\n    stream._sentEnd = true\n    let err\n    if (frame.errorMessage) {\n      err = new Error(frame.errorMessage)\n      err.name = ErrorCode[frame.errorCode]\n    }\n    stream._remoteEnded(err)\n\n    // TODO make sure we don't send more than one of these frames per packet\n    this.maxStreamId += 2\n    this.log.trace('raising maxStreamId to %d', this.maxStreamId)\n    this.queuedFrames.push(new ConnectionMaxStreamIdFrame(this.maxStreamId))\n    // Start send loop to make sure this frame is sent\n    this.startSendLoop()\n  }\n\n  /**\n   * (Internal) Start sending packets with money and/or data, as necessary.\n   * @private\n   */\n  protected async startSendLoop() {\n    if (this.looping) {\n      // `sending` may be `false`, but the loop has not yet exited.\n      // Setting `true` ensures that it will try to loop at least once more before stopping,\n      // ensuring whatever changes triggered this `startSendLoop` call are sent.\n      this.sending = true\n      return\n    }\n    if (this.remoteState === RemoteState.Closed) {\n      this.log.debug('remote connection is already closed, not starting another loop')\n      this.safeEmit('_send_loop_finished')\n      return\n    }\n    if (!this._destinationAccount) {\n      this.log.debug(\"not sending because we do not know the client's address\")\n      this.safeEmit('_send_loop_finished')\n      return\n    }\n\n    this.looping = true\n    this.sending = true\n    this.log.debug('starting send loop')\n\n    try {\n      while (this.sending) {\n        if (!this.connected) {\n          await this.setupExchangeRate()\n          this.connected = true\n        } else {\n          // TODO Send multiple packets at the same time (don't await promise)\n          // TODO Figure out if we need to wait before sending the next one\n          await this.loadAndSendPacket()\n        }\n      }\n      this.looping = false\n    } catch (err) {\n      this.looping = false\n      // TODO should a connection error be an error on all of the streams?\n      return this.destroy(err instanceof Error ? err : undefined)\n    }\n    this.log.debug('finished sending')\n    this.safeEmit('_send_loop_finished')\n    for (const [_, stream] of this.streams) {\n      stream.emit('_send_loop_finished')\n    }\n  }\n\n  /**\n   * Load up a packet money and/or data, send it to the other party, and handle the result.\n   * @private\n   */\n  protected async loadAndSendPacket(): Promise<void> {\n    // Actually send on the next tick of the event loop in case multiple streams\n    // have their limits raised at the same time\n    await new Promise((resolve) => setTimeout(resolve))\n\n    this.log.trace('loadAndSendPacket')\n    let amountToSend = Long.UZERO\n\n    // TODO make sure the queued frames aren't too big\n    const requestPacket = new Packet(\n      this.getNextPacketSequence(),\n      IlpPacketType.Prepare,\n      undefined,\n      this.queuedFrames\n    )\n    this.queuedFrames = []\n\n    // This is usually handled by the first test packet, but when the exchange rate\n    // is fixed it happens here instead.\n    this.maybePushAccountFrames(requestPacket)\n\n    // Send control frames\n    // TODO only send the max amount when it changes\n    for (const [_, stream] of this.streams) {\n      if (stream.isOpen()) {\n        requestPacket.frames.push(\n          new StreamMaxMoneyFrame(stream.id, stream.receiveMax, stream.totalReceived)\n        )\n        requestPacket.frames.push(\n          new StreamMaxDataFrame(stream.id, stream._getIncomingOffsets().maxAcceptable)\n        )\n      }\n    }\n\n    if (this.closed && this.remoteState === RemoteState.Connected) {\n      // TODO how do we know if there was an error?\n      this.log.trace('sending connection close frame')\n      requestPacket.frames.push(new ConnectionCloseFrame(ErrorCode.NoError, ''))\n      // TODO don't put any more frames because the connection is closed\n      // TODO only mark this as closed once we confirm that with the receiver\n      this.remoteState = RemoteState.Closed\n    }\n\n    if (!this.exchangeRate) {\n      // This shouldn't happen because loadAndSendPacket is only called after the exchange rate is established\n      throw new Error('Tried to send without an exchange rate established')\n    }\n\n    // Determine how much to send based on amount frames and path maximum packet amount\n    let maxAmountFromNextStream = this.congestion.testMaximumPacketAmount\n    if (this.exchangeRate.greaterThanOne()) {\n      // Ensure that the packet's PrepareAmount will never be larger than MAX_UNSIGNED_VALUE.\n      maxAmountFromNextStream = minLong(\n        maxAmountFromNextStream,\n        this.exchangeRate.reciprocal().multiplyByLong(Long.MAX_UNSIGNED_VALUE)\n      )\n    }\n    const streamsSentFrom = []\n    for (const [_, stream] of this.streams) {\n      if (stream._sentEnd) {\n        // TODO just remove closed streams?\n        continue\n      }\n      // Determine how much to send from this stream based on how much it has available\n      // and how much the receiver side of this stream can receive\n      let amountToSendFromStream = minLong(\n        stream._getAmountAvailableToSend(),\n        maxAmountFromNextStream\n      )\n      const maxDestinationAmount = checkedSubtract(\n        stream._remoteReceiveMax,\n        stream._remoteReceived\n      ).difference\n      const maxSourceAmount = this.exchangeRate\n        .reciprocal()\n        .multiplyByLongCeil(maxDestinationAmount)\n      if (maxSourceAmount.lessThan(amountToSendFromStream)) {\n        this.log.trace(\n          \"stream %d could send %s but that would be more than the receiver says they can receive, so we'll send %s instead\",\n          stream.id,\n          amountToSendFromStream,\n          maxSourceAmount\n        )\n        amountToSendFromStream = maxSourceAmount\n      }\n      this.log.trace(\n        'amount to send from stream %d: %s, exchange rate: %s, remote total received: %s, remote receive max: %s',\n        stream.id,\n        amountToSendFromStream,\n        this.exchangeRate,\n        stream._remoteReceived,\n        stream._remoteReceiveMax\n      )\n\n      // Hold the money and add a frame to the packet\n      if (amountToSendFromStream.greaterThan(0)) {\n        stream._holdOutgoing(requestPacket.sequence.toString(), amountToSendFromStream)\n        // TODO make sure the length of the frames doesn't exceed packet data limit\n        requestPacket.frames.push(new StreamMoneyFrame(stream.id, amountToSendFromStream))\n        amountToSend = amountToSend.add(amountToSendFromStream)\n        maxAmountFromNextStream = maxAmountFromNextStream.subtract(amountToSendFromStream)\n        streamsSentFrom.push(stream)\n      }\n\n      // Tell peer if they're blocking us from sending money\n      const amountLeftStreamWantsToSend = Long.fromString(stream.sendMax, true)\n        .subtract(stream.totalSent)\n        .subtract(amountToSendFromStream)\n      if (\n        this.exchangeRate\n          .multiplyByLong(amountLeftStreamWantsToSend)\n          .greaterThan(checkedSubtract(stream._remoteReceiveMax, stream._remoteReceived).difference)\n      ) {\n        requestPacket.frames.push(\n          new StreamMoneyBlockedFrame(stream.id, stream.sendMax, stream.totalSent)\n        )\n      }\n\n      if (maxAmountFromNextStream.equals(0)) {\n        // TODO make sure that we start with those later frames the next time around\n        break\n      }\n    }\n\n    let bytesLeftInPacket = MAX_DATA_SIZE - requestPacket.byteLength()\n\n    // Respect connection-level flow control\n    const maxBytesRemoteConnectionCanReceive =\n      this.remoteMaxOffset - this.getOutgoingOffsets().currentOffset\n    if (bytesLeftInPacket > maxBytesRemoteConnectionCanReceive) {\n      const outgoingMaxOffset = this.getOutgoingOffsets().maxOffset\n      this.log.debug(\n        'peer is blocking us from sending more data. they will only accept up to offset: %d, but we want to send up to: %d',\n        this.remoteMaxOffset,\n        outgoingMaxOffset\n      )\n      requestPacket.frames.push(new ConnectionDataBlockedFrame(outgoingMaxOffset))\n      bytesLeftInPacket = maxBytesRemoteConnectionCanReceive\n    }\n\n    for (const [_, stream] of this.streams) {\n      // TODO use a sensible estimate for the StreamDataFrame overhead\n      if (bytesLeftInPacket - 20 <= 0) {\n        // Never pass a negative offset to _getAmountAvailableToSend.\n        break\n      }\n      const { data, offset } = stream._getAvailableDataToSend(bytesLeftInPacket - 20)\n      if (data && data.length > 0) {\n        const streamDataFrame = new StreamDataFrame(stream.id, offset, data)\n        this.log.trace('sending %d bytes from stream %d', data.length, stream.id)\n        bytesLeftInPacket -= streamDataFrame.byteLength()\n        requestPacket.frames.push(streamDataFrame)\n      }\n\n      // Inform remote which streams are blocked\n      const maxOutgoingOffset = stream._isDataBlocked()\n      if (maxOutgoingOffset) {\n        this.log.trace(\n          'telling remote that stream %d is blocked and has more data to send',\n          stream.id\n        )\n        requestPacket.frames.push(new StreamDataBlockedFrame(stream.id, maxOutgoingOffset))\n      }\n    }\n\n    // Check if we can stop sending\n    if (amountToSend.equals(0)) {\n      if (requestPacket.frames.length === 0) {\n        this.sending = false\n        return\n      } else {\n        // Check if any Close, Data, or Money Frames are present in the packet.\n        // If any of those are do not sent sending to false so the send loop\n        // has an opportunity to retry if those packets are rejected.\n        if (\n          !requestPacket.frames.find(\n            (frame) =>\n              frame.type === FrameType.StreamClose ||\n              frame.type === FrameType.StreamData ||\n              frame.type === FrameType.StreamMoney\n          )\n        ) {\n          this.sending = false\n        }\n      }\n    }\n\n    // Set minimum destination amount\n    const minimumDestinationAmount = this.slippage\n      .complement()\n      .multiplyByLong(this.exchangeRate.multiplyByLong(amountToSend))\n    if (minimumDestinationAmount.greaterThan(0)) {\n      requestPacket.prepareAmount = minimumDestinationAmount\n    }\n\n    const responsePacket = await this.sendPacket(requestPacket, amountToSend, false)\n\n    if (responsePacket) {\n      if (this.remoteState === RemoteState.Init) {\n        this.remoteState = RemoteState.Connected\n      }\n      this.remoteKnowsOurAccount = true\n      this.handleControlFrames(responsePacket.frames)\n\n      // Track the exchange rate for the last packet (whether it was fulfilled or rejected)\n      if (amountToSend.greaterThan(0)) {\n        this._lastPacketExchangeRate = new Rational(\n          responsePacket.prepareAmount,\n          amountToSend,\n          true\n        )\n      }\n\n      if (responsePacket.ilpPacketType === IlpPacketType.Fulfill) {\n        for (const frame of responsePacket.frames) {\n          if (frame.type === FrameType.StreamReceipt) {\n            const stream = this.streams.get(frame.streamId.toNumber())\n            if (stream) {\n              stream._setReceipt(frame.receipt)\n            } else {\n              this.log.debug(\n                'received receipt for unknown stream %d: %h',\n                frame.streamId,\n                frame.receipt\n              )\n            }\n          }\n        }\n\n        for (const stream of streamsSentFrom) {\n          stream._executeHold(requestPacket.sequence.toString())\n        }\n\n        // Update stats based on amount sent\n        this.addTotalDelivered(responsePacket.prepareAmount)\n        this.addTotalSent(amountToSend)\n        this.congestion.onFulfill(amountToSend)\n\n        // Reset the retry delay\n        this.retryDelay = RETRY_DELAY_START\n      }\n    }\n  }\n\n  /**\n   * (Internal) Send volley of test packets to find the exchange rate, its precision, and potential other amounts to try.\n   * @private\n   */\n  protected async sendTestPacketVolley(testPacketAmounts: Long[]): Promise<TestVolleyResult> {\n    const results = await Promise.all(\n      testPacketAmounts.map(async (amount) => {\n        try {\n          return this.sendTestPacket(amount)\n        } catch (err) {\n          this.log.error('Error sending test packet for amount %d: %s', amount, err)\n          return null\n        }\n      })\n    )\n\n    // parse F08 packets and get the max packet amounts from them\n    const maxPacketAmounts = testPacketAmounts.map((sourceAmount, index) => {\n      if (results[index] && (results[index] as IlpPacket.IlpReject).code === 'F08') {\n        try {\n          const reader = Reader.from((results[index] as IlpPacket.IlpReject).data)\n          const receivedAmount = reader.readUInt64Long()\n          const maximumAmount = reader.readUInt64Long()\n          const maximumPacketAmount = multiplyDivideFloor(\n            sourceAmount,\n            maximumAmount,\n            receivedAmount\n          )\n          this.log.debug(\n            'sending test packet of %d resulted in F08 error that told us maximum packet amount is %s',\n            testPacketAmounts[index],\n            maximumPacketAmount\n          )\n          return maximumPacketAmount\n        } catch (err) {\n          return Long.MAX_UNSIGNED_VALUE\n        }\n      }\n      return Long.MAX_UNSIGNED_VALUE\n    })\n\n    // Figure out which test packet discovered the exchange rate with the most precision and gather packet error codes\n    return results.reduce<TestVolleyResult>(\n      ({ maxDigits, exchangeRate, maxPacketAmounts, packetErrors }, result, index) => {\n        const sourceAmount = testPacketAmounts[index]\n        if (result && (result as IlpPacket.IlpReject).code) {\n          packetErrors.push({\n            sourceAmount,\n            code: (result as IlpPacket.IlpReject).code,\n          })\n        }\n        if (result && (result as Packet).prepareAmount) {\n          const prepareAmount = (result as Packet).prepareAmount\n          const exchangeRate = new Rational(prepareAmount, sourceAmount, true)\n          this.log.debug(\n            'sending test packet of %d delivered %s (exchange rate: %s)',\n            sourceAmount,\n            prepareAmount,\n            exchangeRate\n          )\n          if (countDigits(prepareAmount) >= maxDigits) {\n            return {\n              maxDigits: countDigits(prepareAmount),\n              exchangeRate,\n              maxPacketAmounts,\n              packetErrors,\n            }\n          }\n        }\n        return { maxDigits, exchangeRate, maxPacketAmounts, packetErrors }\n      },\n      { maxDigits: 0, exchangeRate: Rational.UZERO, maxPacketAmounts, packetErrors: [] }\n    )\n  }\n\n  protected async setupExchangeRate(): Promise<void> {\n    if (!this.exchangeRate) {\n      this.log.trace('determining exchange rate')\n      await this.determineExchangeRate()\n    }\n    // 'connect' is not emitted immediately because `connect()` needs to be listening,\n    // and when `exchangeRate` is fixed it isn't yet.\n    process.nextTick(() => {\n      this.safeEmit('connect')\n      this.log.trace('connected')\n    })\n  }\n\n  /**\n   * (Internal) Probe using test packets to find the exchange rate.\n   * @private\n   */\n  protected async determineExchangeRate(): Promise<void> {\n    this.log.trace('determineExchangeRate')\n    if (!this._destinationAccount) {\n      throw new Error('Cannot determine exchange rate. Destination account is unknown')\n    }\n\n    let retryDelay = RETRY_DELAY_START\n    let testPacketAmounts = [1, 1e3, 1e6, 1e9, 1e12].map((num) => Long.fromNumber(num, true))\n    let attempts = 0\n\n    // set a max attempts in case F08 & TXX errors keep occurring\n    while (\n      !this.exchangeRate &&\n      testPacketAmounts.length > 0 &&\n      attempts < TEST_PACKET_MAX_ATTEMPTS\n    ) {\n      attempts++\n      const { maxDigits, exchangeRate, maxPacketAmounts, packetErrors } =\n        await this.sendTestPacketVolley(testPacketAmounts)\n\n      this.congestion.setMaximumAmounts(\n        minLongs(maxPacketAmounts.concat(this.congestion.maximumPacketAmount))\n      )\n      if (this.congestion.maximumPacketAmount.equals(0)) {\n        this.log.error('cannot send anything through this path. the maximum packet amount is 0')\n        throw new Error('Cannot send. Path has a Maximum Packet Amount of 0')\n      }\n\n      if (maxDigits >= this.minExchangeRatePrecision) {\n        this.log.debug(\n          'determined exchange rate to be %s with %d digits precision',\n          exchangeRate,\n          maxDigits\n        )\n        this.exchangeRate = exchangeRate\n        return\n      }\n\n      // If we get here the first volley failed, try new volley using all unique packet amounts based on the max packets\n      testPacketAmounts = maxPacketAmounts\n        .filter((amount: Long) => !amount.equals(Long.MAX_UNSIGNED_VALUE))\n        .reduce((acc: string[], curr: Long) => [...new Set([...acc, curr.toString()])], [])\n        .map((str) => Long.fromString(str, true))\n\n      // Check for any Txx Errors\n      if (packetErrors.some((error: PacketError) => error.code[0] === 'T')) {\n        // Find the smallest packet amount we tried in case we ran into Txx errors\n        const smallestPacketAmount = packetErrors.reduce((min: Long, error: PacketError) => {\n          return minLong(min, error.sourceAmount)\n        }, Long.MAX_UNSIGNED_VALUE)\n        const reducedPacketAmount = smallestPacketAmount.subtract(smallestPacketAmount.divide(3))\n        this.log.debug(\n          'got Txx error(s), waiting %dms and reducing packet amount to %s before sending another test packet',\n          retryDelay,\n          reducedPacketAmount\n        )\n        testPacketAmounts = [...testPacketAmounts, reducedPacketAmount]\n        await this.rateRetryTimer.wait(retryDelay).catch((_err) => {\n          this.log.debug(\n            'connection terminated before rate could be determined; delay=%d',\n            retryDelay\n          )\n          throw new Error('Connection terminated before rate could be determined.')\n        })\n        retryDelay *= RETRY_DELAY_INCREASE_FACTOR\n      }\n\n      this.log.debug('retry with packet amounts %j', testPacketAmounts)\n    }\n\n    throw new Error(\n      `Unable to establish connection, no packets meeting the minimum exchange precision of ${this.minExchangeRatePrecision} digits made it through the path.`\n    )\n  }\n\n  private stopTimers(): void {\n    if (this.rateRetryTimer) this.rateRetryTimer.stop()\n    if (this.idleTimer) clearTimeout(this.idleTimer)\n    this.done = true\n  }\n\n  /**\n   * (Internal) Send an unfulfillable test packet. Primarily used for determining the path exchange rate.\n   * @private\n   */\n  protected async sendTestPacket(\n    amount: Long,\n    timeout = DEFAULT_PACKET_TIMEOUT\n  ): Promise<Packet | IlpPacket.IlpReject | null> {\n    // Set packet number to correlate response with request\n    const requestPacket = new Packet(this.getNextPacketSequence(), IlpPacketType.Prepare)\n\n    this.log.trace(\n      'sending test packet %s for amount: %s. timeout: %d',\n      requestPacket.sequence,\n      amount,\n      timeout\n    )\n\n    this.maybePushAccountFrames(requestPacket)\n\n    if (!this._destinationAccount) {\n      this.log.error('tried to send test packet without having a destination account')\n      throw new Error('Tried to send test packet without having a destination account')\n    }\n\n    const prepare: IlpPacket.IlpPrepare = {\n      destination: this._destinationAccount,\n      amount: amount.toString(),\n      data: await requestPacket.serializeAndEncrypt(this._pskKey),\n      executionCondition: cryptoHelper.generateRandomCondition(),\n      expiresAt: this.getExpiry(this._destinationAccount),\n    }\n\n    const responseData = await new Promise<Buffer | null>((resolve, reject) => {\n      const timer = setTimeout(() => {\n        this.log.error('test packet %s timed out before we got a response', requestPacket.sequence)\n        resolve(null)\n      }, timeout)\n      this.plugin\n        .sendData(IlpPacket.serializeIlpPrepare(prepare))\n        .then((result) => {\n          clearTimeout(timer)\n          resolve(result)\n        })\n        .catch(reject)\n    })\n\n    if (!responseData) {\n      return null\n    }\n    this.bumpIdle()\n\n    const ilpReject = IlpPacket.deserializeIlpReject(responseData)\n\n    // Return the receiver's response if there was one\n    let responsePacket\n    if (ilpReject.code === 'F99' && ilpReject.data.length > 0) {\n      responsePacket = await Packet.decryptAndDeserialize(this._pskKey, ilpReject.data)\n\n      // Ensure the response corresponds to the request\n      if (!responsePacket.sequence.equals(requestPacket.sequence)) {\n        this.log.error(\n          'response packet sequence does not match the request packet. expected sequence: %s, got response packet: %j',\n          requestPacket.sequence,\n          responsePacket\n        )\n        throw new Error(\n          `Response packet sequence does not correspond to the request. Actual: ${responsePacket.sequence}, expected: ${requestPacket.sequence}`\n        )\n      }\n      if (responsePacket.ilpPacketType !== responseData[0]) {\n        this.log.error(\n          'response packet was on wrong ILP packet type. expected ILP packet type: %d, got: %j',\n          responseData[0],\n          responsePacket\n        )\n        throw new Error(\n          `Response says it should be on an ILP packet of type: ${responsePacket.ilpPacketType} but it was carried on an ILP packet of type: ${responseData[0]}`\n        )\n      }\n    } else {\n      this.log.debug(\n        'test packet %s was rejected with a %s triggered by %s error%s',\n        requestPacket.sequence,\n        ilpReject.code,\n        ilpReject.triggeredBy,\n        ilpReject.message ? ' with the message: \"' + ilpReject.message + '\"' : ''\n      )\n    }\n\n    if (responsePacket) {\n      this.remoteKnowsOurAccount = true\n      this.handleControlFrames(responsePacket.frames)\n      return responsePacket\n    } else {\n      return ilpReject\n    }\n  }\n\n  /**\n   * Send a ConnectionClose frame to the other side\n   */\n  protected async sendConnectionClose(err?: ConnectionError | Error): Promise<void> {\n    if (this.remoteState === RemoteState.Closed) {\n      this.log.debug('not sending connection error because remote is already closed')\n      return\n    }\n\n    let errorCode: ErrorCode\n    let errorMessage\n    if (err && err instanceof ConnectionError) {\n      errorCode = err.streamErrorCode\n      errorMessage = err.message\n    } else if (err) {\n      errorCode = ErrorCode.InternalError\n      errorMessage = err.message\n    } else {\n      errorCode = ErrorCode.NoError\n      errorMessage = ''\n    }\n\n    const packet = new Packet(this.nextPacketSequence++, IlpPacketType.Prepare, 0, [\n      new ConnectionCloseFrame(errorCode, errorMessage),\n    ])\n\n    try {\n      if (!this._destinationAccount) {\n        this.log.error('tried to close connection without having a destination account')\n        throw new Error('Tried to close connection without having a destination account')\n      }\n\n      const prepare: IlpPacket.IlpPrepare = {\n        destination: this._destinationAccount,\n        amount: '0',\n        data: await packet.serializeAndEncrypt(this._pskKey),\n        executionCondition: cryptoHelper.generateRandomCondition(),\n        expiresAt: this.getExpiry(this._destinationAccount),\n      }\n      await this.plugin.sendData(IlpPacket.serializeIlpPrepare(prepare))\n    } catch (err) {\n      this.log.error(\n        'error while trying to inform peer that connection is closing, but closing anyway',\n        err\n      )\n    }\n    this.remoteState = RemoteState.Closed\n  }\n\n  /**\n   * Helper function used to send all ILP Prepare packets.\n   * This automatically generates the condition and sets the packet expiry.\n   * It also ensures that responses are valid and match the outgoing request.\n   */\n  protected async sendPacket(\n    packet: Packet,\n    sourceAmount: Long,\n    unfulfillable = false\n  ): Promise<Packet | void> {\n    this.log.trace(\n      'sending packet %s with source amount: %s: %j',\n      packet.sequence,\n      sourceAmount,\n      packet\n    )\n    const data = await packet.serializeAndEncrypt(\n      this._pskKey,\n      this.enablePadding ? MAX_DATA_SIZE : undefined\n    )\n\n    let fulfillment: Buffer | undefined\n    let executionCondition: Buffer\n    if (unfulfillable) {\n      fulfillment = undefined\n      executionCondition = cryptoHelper.generateRandomCondition()\n    } else {\n      fulfillment = await cryptoHelper.generateFulfillment(this._fulfillmentKey, data)\n      executionCondition = await cryptoHelper.hash(fulfillment)\n    }\n\n    if (!this._destinationAccount) {\n      this.log.error('tried to send a packet without having a destination account')\n      throw new Error('Tried to send a packet without having a destination account')\n    }\n\n    const prepare: IlpPacket.IlpPrepare = {\n      destination: this._destinationAccount,\n      amount: sourceAmount.toString(),\n      data,\n      executionCondition,\n      expiresAt: this.getExpiry(this._destinationAccount),\n    }\n\n    const responseData = await this.plugin.sendData(IlpPacket.serializeIlpPrepare(prepare))\n    this.bumpIdle()\n\n    let response: IlpPacket.IlpFulfill | IlpPacket.IlpReject\n    try {\n      if (responseData[0] === IlpPacket.Type.TYPE_ILP_FULFILL) {\n        response = IlpPacket.deserializeIlpFulfill(responseData)\n      } else if (responseData[0] === IlpPacket.Type.TYPE_ILP_REJECT) {\n        response = IlpPacket.deserializeIlpReject(responseData)\n      } else {\n        throw new Error(`Invalid response packet type: ${responseData[0]}`)\n      }\n    } catch (err) {\n      this.log.error(\n        'got invalid response from sending packet %s: %s %h',\n        packet.sequence,\n        err,\n        responseData\n      )\n      throw new Error(\n        `Invalid response when sending packet ${packet.sequence}: ${\n          err instanceof Error ? err.message : err\n        }`\n      )\n    }\n\n    // Handle fulfillment\n    if (fulfillment && isFulfill(response)) {\n      if (!(await cryptoHelper.hash(response.fulfillment)).equals(executionCondition)) {\n        this.log.error(\n          'got invalid fulfillment for packet %s: %h. expected: %h for condition: %h',\n          packet.sequence,\n          response.fulfillment,\n          fulfillment,\n          executionCondition\n        )\n        throw new Error(\n          `Got invalid fulfillment for packet ${\n            packet.sequence\n          }. Actual: ${response.fulfillment.toString('hex')}, expected: ${fulfillment.toString(\n            'hex'\n          )}`\n        )\n      }\n    } else {\n      response = response as IlpPacket.IlpReject\n\n      this.undoRejectedPacket(packet)\n\n      if (response.code !== 'F99') {\n        return this.handleConnectorError(response, sourceAmount)\n      }\n    }\n\n    // TODO correctly handle fulfills that come back without data attached (this will be treated like a reject)\n    if (response.data.length === 0) {\n      return undefined\n    }\n\n    // Parse response data from receiver\n    let responsePacket: Packet\n    try {\n      responsePacket = await Packet.decryptAndDeserialize(this._pskKey, response.data)\n    } catch (err) {\n      this.log.error('unable to decrypt and parse response data: %s %h', err)\n      // TODO should we continue processing anyway? what if it was fulfilled?\n      throw new Error(\n        `Unable to decrypt and parse response data: ${err instanceof Error ? err.message : err}`\n      )\n    }\n\n    // Ensure the response corresponds to the request\n    if (!responsePacket.sequence.equals(packet.sequence)) {\n      this.log.error(\n        'response packet sequence does not match the request packet. expected sequence: %s, got response packet: %j',\n        packet.sequence,\n        responsePacket\n      )\n      throw new Error(\n        `Response packet sequence does not correspond to the request. Actual: ${responsePacket.sequence}, expected: ${packet.sequence}`\n      )\n    }\n    if (responsePacket.ilpPacketType !== responseData[0]) {\n      this.log.error(\n        'response packet was on wrong ILP packet type. expected ILP packet type: %d, got: %j',\n        responseData[0],\n        responsePacket\n      )\n      throw new Error(\n        `Response says it should be on an ILP packet of type: ${responsePacket.ilpPacketType} but it was carried on an ILP packet of type: ${responseData[0]}`\n      )\n    }\n\n    this.log.debug('got response to packet: %s: %j', packet.sequence, responsePacket)\n\n    return responsePacket\n  }\n\n  /**\n   * Roll back the effects of an outgoing packet that was rejected\n   * @private\n   */\n  protected undoRejectedPacket(requestPacket: Packet) {\n    this.log.debug('packet %s was rejected', requestPacket.sequence)\n\n    // TODO resend control frames\n    for (const frame of requestPacket.frames) {\n      switch (frame.type) {\n        case FrameType.StreamMoney: {\n          const stream = this.streams.get(frame.streamId.toNumber())\n          if (stream) stream._cancelHold(requestPacket.sequence.toString())\n          break\n        }\n        case FrameType.StreamData: {\n          const stream = this.streams.get(frame.streamId.toNumber())\n          if (stream) stream._resendOutgoingData(frame.data, frame.offset.toNumber())\n          break\n        }\n        case FrameType.StreamClose:\n          this.queuedFrames.push(frame)\n          break\n        default:\n          continue\n      }\n    }\n  }\n\n  /**\n   * (Internal) Handle final and temporary errors that were not generated by the receiver.\n   * @private\n   */\n  protected async handleConnectorError(reject: IlpPacket.IlpReject, amountSent: Long) {\n    this.log.debug(\n      'handling reject triggered by: %s error: %s message: %s data: %h',\n      reject.triggeredBy,\n      reject.code,\n      reject.message,\n      reject.data\n    )\n    if (reject.code === 'F08') {\n      const maximumPacketAmount = this.congestion.onAmountTooLargeError(reject, amountSent)\n      if (maximumPacketAmount.equals(0)) {\n        this.log.error('cannot send anything through this path. the maximum packet amount is 0')\n        throw new Error('Cannot send. Path has a Maximum Packet Amount of 0')\n      }\n    } else if (reject.code[0] === 'T') {\n      if (reject.code === 'T04') {\n        this.congestion.onInsufficientLiquidityError(reject, amountSent)\n      }\n\n      // TODO should we reduce the packet amount on other TXX errors too?\n      this.log.warn(\n        'got %s temporary error triggered by: %s. waiting %dms before trying again',\n        reject.code,\n        reject.triggeredBy,\n        this.retryDelay\n      )\n      const delay = this.retryDelay\n      this.retryDelay = Math.min(this.retryDelay * 2, RETRY_DELAY_MAX)\n      await new Promise((resolve) => setTimeout(resolve, delay))\n    } else {\n      this.log.error(\n        'unexpected error. code: %s, triggered by: %s, message: %s, data: %h',\n        reject.code,\n        reject.triggeredBy,\n        reject.message,\n        reject.data\n      )\n      // This error will terminate the connection and bubble out to the caller.\n      const error = new IlpRejectionError(\n        `Unexpected error while sending packet. Code: ${reject.code}, triggered by: ${reject.triggeredBy}, message: ${reject.message}`,\n        reject\n      )\n      throw error\n    }\n  }\n\n  protected safeEmit(...args: Parameters<typeof EventEmitter.prototype.emit>) {\n    const event = args[0]\n    try {\n      this.emit(...args)\n    } catch (err) {\n      this.log.debug('error in %s handler: %s', event, err)\n    }\n  }\n\n  protected getOutgoingOffsets(): { currentOffset: number; maxOffset: number } {\n    let currentOffset = 0\n    let maxOffset = 0\n\n    for (const [_, stream] of this.streams) {\n      const streamOffsets = stream._getOutgoingOffsets()\n      currentOffset += streamOffsets.current\n      maxOffset += streamOffsets.max\n    }\n    return {\n      currentOffset,\n      maxOffset,\n    }\n  }\n\n  protected getIncomingOffsets(): { current: number; max: number; maxAcceptable: number } {\n    let totalMaxOffset = 0\n    let totalReadOffset = 0\n    let totalBufferedData = 0\n    for (const [_, stream] of this.streams) {\n      const { max, current } = stream._getIncomingOffsets()\n      totalMaxOffset += max\n      totalReadOffset += current\n      totalBufferedData += stream.readableLength\n    }\n\n    return {\n      current: totalReadOffset,\n      max: totalMaxOffset,\n      maxAcceptable: totalReadOffset - totalBufferedData + this.maxBufferedData,\n    }\n  }\n\n  protected removeStreamRecord(stream: DataAndMoneyStream) {\n    this.log.debug('removing record of stream %d', stream.id)\n    this.streams.delete(stream.id)\n    this.closedStreams.add(stream.id)\n    this.safeEmit('_stream_removed')\n    if (!stream._sentEnd) {\n      stream._sentEnd = true\n      const streamEndFrame = stream._errorMessage\n        ? new StreamCloseFrame(stream.id, ErrorCode.ApplicationError, stream._errorMessage)\n        : new StreamCloseFrame(stream.id, ErrorCode.NoError, '')\n      this.queuedFrames.push(streamEndFrame)\n      setTimeout(() => this.startSendLoop())\n    }\n  }\n\n  private startIdleTimer(): void {\n    if (this.idleTimeout === 0) return\n    const idle = Date.now() - this.lastActive.getTime()\n    this.idleTimer = setTimeout(() => this.testIdle(), this.idleTimeout - idle)\n    // browser timers don't support unref\n    if (typeof this.idleTimer.unref === 'function') {\n      this.idleTimer.unref()\n    }\n    this.log.trace('(re)starting idle timeout for %dms from now', this.idleTimeout)\n  }\n\n  private testIdle(): void {\n    this.log.trace('idle timeout reached')\n    const idle = Date.now() - this.lastActive.getTime()\n    if (idle >= this.idleTimeout) {\n      this.log.error('Connection timed out due to inactivity, destroying connection')\n      this.destroy(new Error('Connection timed out due to inactivity'))\n    } else {\n      this.startIdleTimer()\n    }\n  }\n\n  private bumpIdle(): void {\n    this.lastActive = new Date()\n  }\n\n  private addIncomingHold(value: Long): void {\n    let result = checkedAdd(this._totalReceived, this._incomingHold)\n    result = checkedAdd(result.sum, value)\n\n    if (result.overflow) {\n      const err = new IlpPacket.Errors.BadRequestError('Total received exceeded MaxUint64')\n      this.destroy(err)\n      throw err\n    } else {\n      this._incomingHold = result.sum\n    }\n  }\n\n  private removeIncomingHold(value: Long): void {\n    // As long as this is called after `addIncomingHold` for the same amount,\n    // this should never underflow\n    this._incomingHold = checkedSubtract(this._incomingHold, value).difference\n  }\n\n  private addTotalReceived(value: Long): void {\n    // As long as this is called after `addIncomingHold` for the same amount,\n    // this should never overflow\n    this._totalReceived = checkedAdd(this._totalReceived, value).sum\n  }\n\n  private addTotalSent(value: Long): void {\n    const result = checkedAdd(this._totalSent, value)\n    if (result.overflow) {\n      const err = new IlpPacket.Errors.BadRequestError('Total sent exceeded MaxUint64')\n      this.destroy(err)\n      throw err\n    } else {\n      this._totalSent = result.sum\n    }\n  }\n\n  private addTotalDelivered(value: Long): void {\n    const result = checkedAdd(this._totalDelivered, value)\n    if (result.overflow) {\n      const err = new IlpPacket.Errors.BadRequestError('Total delivered exceeded MaxUint64')\n      this.destroy(err)\n      throw err\n    } else {\n      this._totalDelivered = result.sum\n    }\n  }\n\n  private getNextPacketSequence(): number {\n    const sequence = this.nextPacketSequence++\n    if (sequence >= 2 ** 31) {\n      // Destroy the connection when too many packets are sent (see https://github.com/interledger/rfcs/blob/master/0029-stream/0029-stream.md#513-maximum-number-of-packets-per-connection).\n      //\n      // Throwing here will abort the current send and `destroy()` the connection.\n      throw new ConnectionError(\n        'Connection exceeded maximum number of packets',\n        ErrorCode.InternalError\n      )\n    }\n    return sequence\n  }\n\n  private maybePushAccountFrames(requestPacket: Packet) {\n    if (!this.remoteKnowsOurAccount) {\n      // TODO attach a token to the account?\n      requestPacket.frames.push(new ConnectionNewAddressFrame(this._sourceAccount))\n      requestPacket.frames.push(\n        new ConnectionAssetDetailsFrame(this._sourceAssetCode, this._sourceAssetScale)\n      )\n    }\n  }\n}\n\nfunction isFulfill(\n  packet: IlpPacket.IlpFulfill | IlpPacket.IlpReject\n): packet is IlpPacket.IlpFulfill {\n  return Object.prototype.hasOwnProperty.call(packet, 'fulfillment')\n}\n"]}