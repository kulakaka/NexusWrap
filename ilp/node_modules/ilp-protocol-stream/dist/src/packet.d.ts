/// <reference types="node" />
import { Reader, WriterInterface } from 'oer-utils';
import * as IlpPacket from 'ilp-packet';
import Long from 'long';
import { LongValue } from './util/long';
export declare const IlpPacketType: {
    Prepare: IlpPacket.Type;
    Fulfill: IlpPacket.Type;
    Reject: IlpPacket.Type;
};
export declare enum ErrorCode {
    NoError = 1,
    InternalError = 2,
    EndpointBusy = 3,
    FlowControlError = 4,
    StreamIdError = 5,
    StreamStateError = 6,
    FrameFormatError = 7,
    ProtocolViolation = 8,
    ApplicationError = 9
}
export declare enum FrameType {
    ConnectionClose = 1,
    ConnectionNewAddress = 2,
    ConnectionMaxData = 3,
    ConnectionDataBlocked = 4,
    ConnectionMaxStreamId = 5,
    ConnectionStreamIdBlocked = 6,
    ConnectionAssetDetails = 7,
    StreamClose = 16,
    StreamMoney = 17,
    StreamMaxMoney = 18,
    StreamMoneyBlocked = 19,
    StreamData = 20,
    StreamMaxData = 21,
    StreamDataBlocked = 22,
    StreamReceipt = 23
}
export declare type Frame = ConnectionCloseFrame | ConnectionNewAddressFrame | ConnectionAssetDetailsFrame | ConnectionMaxDataFrame | ConnectionDataBlockedFrame | ConnectionMaxStreamIdFrame | ConnectionStreamIdBlockedFrame | StreamCloseFrame | StreamMoneyFrame | StreamMaxMoneyFrame | StreamMoneyBlockedFrame | StreamDataFrame | StreamMaxDataFrame | StreamDataBlockedFrame | StreamReceiptFrame;
export declare class Packet {
    sequence: Long;
    ilpPacketType: IlpPacket.Type;
    prepareAmount: Long;
    frames: Frame[];
    constructor(sequence: LongValue, ilpPacketType: IlpPacket.Type, packetAmount?: LongValue, frames?: Frame[]);
    static decryptAndDeserialize(pskEncryptionKey: Buffer, buffer: Buffer): Promise<Packet>;
    static _deserializeUnencrypted(buffer: Buffer): Packet;
    serializeAndEncrypt(pskEncryptionKey: Buffer, padPacketToSize?: number): Promise<Buffer>;
    _serialize(): Buffer;
    writeTo(writer: WriterInterface): void;
    byteLength(): number;
}
export declare abstract class BaseFrame {
    type: FrameType;
    name: string;
    constructor(name: keyof typeof FrameType);
    static fromContents(_reader: Reader): BaseFrame;
    writeTo<T extends WriterInterface>(writer: T): T;
    protected writeContentsTo<T extends BaseFrame>(this: T, contents: WriterInterface): void;
    byteLength(): number;
}
export declare class ConnectionCloseFrame extends BaseFrame {
    type: FrameType.ConnectionClose;
    errorCode: ErrorCode;
    errorMessage: string;
    constructor(errorCode: ErrorCode, errorMessage: string);
    static fromContents(reader: Reader): ConnectionCloseFrame;
}
export declare class ConnectionNewAddressFrame extends BaseFrame {
    type: FrameType.ConnectionNewAddress;
    sourceAccount: string;
    constructor(sourceAccount: string);
    static fromContents(reader: Reader): ConnectionNewAddressFrame;
}
export declare class ConnectionAssetDetailsFrame extends BaseFrame {
    type: FrameType.ConnectionAssetDetails;
    sourceAssetCode: string;
    sourceAssetScale: number;
    constructor(sourceAssetCode: string, sourceAssetScale: number);
    static fromContents(reader: Reader): ConnectionAssetDetailsFrame;
}
export declare class ConnectionMaxDataFrame extends BaseFrame {
    type: FrameType.ConnectionMaxData;
    maxOffset: Long;
    constructor(maxOffset: LongValue);
    static fromContents(reader: Reader): ConnectionMaxDataFrame;
}
export declare class ConnectionDataBlockedFrame extends BaseFrame {
    type: FrameType.ConnectionDataBlocked;
    maxOffset: Long;
    constructor(maxOffset: LongValue);
    static fromContents(reader: Reader): ConnectionDataBlockedFrame;
}
export declare class ConnectionMaxStreamIdFrame extends BaseFrame {
    type: FrameType.ConnectionMaxStreamId;
    maxStreamId: Long;
    constructor(maxStreamId: LongValue);
    static fromContents(reader: Reader): ConnectionMaxStreamIdFrame;
}
export declare class ConnectionStreamIdBlockedFrame extends BaseFrame {
    type: FrameType.ConnectionStreamIdBlocked;
    maxStreamId: Long;
    constructor(maxStreamId: LongValue);
    static fromContents(reader: Reader): ConnectionStreamIdBlockedFrame;
}
export declare class StreamCloseFrame extends BaseFrame {
    type: FrameType.StreamClose;
    streamId: Long;
    errorCode: ErrorCode;
    errorMessage: string;
    constructor(streamId: LongValue, errorCode: ErrorCode, errorMessage: string);
    static fromContents(reader: Reader): StreamCloseFrame;
}
export declare class StreamMoneyFrame extends BaseFrame {
    type: FrameType.StreamMoney;
    streamId: Long;
    shares: Long;
    constructor(streamId: LongValue, shares: LongValue);
    static fromContents(reader: Reader): StreamMoneyFrame;
}
export declare class StreamMaxMoneyFrame extends BaseFrame {
    type: FrameType.StreamMaxMoney;
    streamId: Long;
    receiveMax: Long;
    totalReceived: Long;
    constructor(streamId: LongValue, receiveMax: LongValue, totalReceived: LongValue);
    static fromContents(reader: Reader): StreamMaxMoneyFrame;
}
export declare class StreamMoneyBlockedFrame extends BaseFrame {
    type: FrameType.StreamMoneyBlocked;
    streamId: Long;
    sendMax: Long;
    totalSent: Long;
    constructor(streamId: LongValue, sendMax: LongValue, totalSent: LongValue);
    static fromContents(reader: Reader): StreamMoneyBlockedFrame;
}
export declare class StreamDataFrame extends BaseFrame {
    type: FrameType.StreamData;
    streamId: Long;
    offset: Long;
    data: Buffer;
    constructor(streamId: LongValue, offset: LongValue, data: Buffer);
    static fromContents(reader: Reader): StreamDataFrame;
    toJSON(): Record<string, unknown>;
}
export declare class StreamMaxDataFrame extends BaseFrame {
    type: FrameType.StreamMaxData;
    streamId: Long;
    maxOffset: Long;
    constructor(streamId: LongValue, maxOffset: LongValue);
    static fromContents(reader: Reader): StreamMaxDataFrame;
}
export declare class StreamDataBlockedFrame extends BaseFrame {
    type: FrameType.StreamDataBlocked;
    streamId: Long;
    maxOffset: Long;
    constructor(streamId: LongValue, maxOffset: LongValue);
    static fromContents(reader: Reader): StreamDataBlockedFrame;
}
export declare class StreamReceiptFrame extends BaseFrame {
    type: FrameType.StreamReceipt;
    streamId: Long;
    receipt: Buffer;
    constructor(streamId: LongValue, receipt: Buffer);
    static fromContents(reader: Reader): StreamReceiptFrame;
    toJSON(): Record<string, unknown>;
}
