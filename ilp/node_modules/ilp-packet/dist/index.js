"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.errorToIlpReject = exports.errorToReject = exports.serializeIlpReply = exports.deserializeIlpReply = exports.deserializeIlpPacket = exports.serializeIlpPacket = exports.deserializeIlpReject = exports.serializeIlpReject = exports.deserializeIlpFulfill = exports.serializeIlpFulfill = exports.isIlpError = exports.isReject = exports.isFulfill = exports.isPrepare = exports.isIlpReply = exports.deserializeIlpPrepare = exports.serializeIlpPrepare = exports.deserializeEnvelope = exports.IlpPacketType = exports.Type = exports.isCanonicalIlpRejectCode = exports.IlpErrorClass = exports.IlpError = exports.IlpErrorCode = exports.getScheme = exports.isValidIlpAddress = exports.Errors = void 0;
const oer_utils_1 = require("oer-utils");
const date_1 = require("./utils/date");
const assert_1 = __importDefault(require("assert"));
const address_1 = require("./utils/address");
Object.defineProperty(exports, "isValidIlpAddress", { enumerable: true, get: function () { return address_1.isValidIlpAddress; } });
const long_1 = __importDefault(require("long"));
const errors = __importStar(require("./errors"));
exports.Errors = errors;
var address_2 = require("./utils/address");
Object.defineProperty(exports, "getScheme", { enumerable: true, get: function () { return address_2.getScheme; } });
var errors_1 = require("./errors");
Object.defineProperty(exports, "IlpErrorCode", { enumerable: true, get: function () { return errors_1.IlpErrorCode; } });
Object.defineProperty(exports, "IlpError", { enumerable: true, get: function () { return errors_1.IlpErrorCode; } });
Object.defineProperty(exports, "IlpErrorClass", { enumerable: true, get: function () { return errors_1.BaseIlpError; } });
const isCanonicalIlpRejectCode = (o) => typeof o === 'string' && Object.values(errors.IlpErrorCode).includes(o);
exports.isCanonicalIlpRejectCode = isCanonicalIlpRejectCode;
var Type;
(function (Type) {
    Type[Type["TYPE_ILP_PREPARE"] = 12] = "TYPE_ILP_PREPARE";
    Type[Type["TYPE_ILP_FULFILL"] = 13] = "TYPE_ILP_FULFILL";
    Type[Type["TYPE_ILP_REJECT"] = 14] = "TYPE_ILP_REJECT";
})(Type = exports.Type || (exports.Type = {}));
var IlpPacketType;
(function (IlpPacketType) {
    IlpPacketType[IlpPacketType["Prepare"] = 12] = "Prepare";
    IlpPacketType[IlpPacketType["Fulfill"] = 13] = "Fulfill";
    IlpPacketType[IlpPacketType["Reject"] = 14] = "Reject";
})(IlpPacketType = exports.IlpPacketType || (exports.IlpPacketType = {}));
const deserializeEnvelope = (binary) => {
    const envelopeReader = oer_utils_1.Reader.from(binary);
    const type = envelopeReader.readUInt8Number();
    const contents = envelopeReader.readVarOctetString();
    return { type, contents };
};
exports.deserializeEnvelope = deserializeEnvelope;
const serializeIlpPrepare = (json) => {
    (0, assert_1.default)(json.amount && typeof json.amount === 'string', 'amount must be a string');
    (0, assert_1.default)(Buffer.isBuffer(json.executionCondition) && json.executionCondition.length === 32, 'executionCondition must be a 32-byte buffer');
    (0, assert_1.default)(json.expiresAt && json.expiresAt instanceof Date, 'expiresAt must be a Date');
    (0, assert_1.default)(typeof json.destination === 'string', 'destination is required');
    (0, assert_1.default)(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer');
    const expiresAt = Buffer.from((0, date_1.dateToInterledgerTime)(json.expiresAt), 'ascii');
    const destination = Buffer.from(json.destination, 'ascii');
    const contentSize = 8 +
        date_1.INTERLEDGER_TIME_LENGTH +
        32 +
        oer_utils_1.Predictor.measureVarOctetString(destination.length) +
        oer_utils_1.Predictor.measureVarOctetString(json.data.length);
    const envelopeSize = 1 + oer_utils_1.Predictor.measureVarOctetString(contentSize);
    const envelope = new oer_utils_1.Writer(envelopeSize);
    envelope.writeUInt8(IlpPacketType.Prepare);
    const content = envelope.createVarOctetString(contentSize);
    content.writeUInt64(json.amount);
    content.write(expiresAt);
    content.write(json.executionCondition);
    content.writeVarOctetString(destination);
    content.writeVarOctetString(json.data);
    return envelope.getBuffer();
};
exports.serializeIlpPrepare = serializeIlpPrepare;
const deserializeIlpPrepare = (binary) => {
    const { type, contents } = (0, exports.deserializeEnvelope)(binary);
    if (type !== IlpPacketType.Prepare) {
        throw new Error('Packet has incorrect type');
    }
    const reader = oer_utils_1.Reader.from(contents);
    const amount = reader.readUInt64();
    const expiresAt = (0, date_1.interledgerTimeToDate)(reader.read(date_1.INTERLEDGER_TIME_LENGTH).toString('ascii'));
    const executionCondition = reader.read(32);
    const destination = reader.readVarOctetString().toString('ascii');
    if (!(0, address_1.isValidIlpAddress)(destination)) {
        throw new Error('Packet has invalid destination address');
    }
    const data = reader.readVarOctetString();
    return {
        amount,
        executionCondition,
        expiresAt,
        destination,
        data,
    };
};
exports.deserializeIlpPrepare = deserializeIlpPrepare;
const isUInt64 = (o) => {
    try {
        const l = long_1.default.fromString(o, true);
        return l.toString() === o;
    }
    catch (_) {
        return false;
    }
};
const isIlpReply = (o) => (0, exports.isFulfill)(o) || (0, exports.isReject)(o);
exports.isIlpReply = isIlpReply;
const isObject = (o) => typeof o === 'object' && o !== null;
const isPrepare = (o) => isObject(o) &&
    typeof o.amount === 'string' &&
    isUInt64(o.amount) &&
    o.expiresAt instanceof Date &&
    !Number.isNaN(o.expiresAt.getTime()) &&
    (0, address_1.isValidIlpAddress)(o.destination) &&
    Buffer.isBuffer(o.executionCondition) &&
    o.executionCondition.byteLength === 32 &&
    Buffer.isBuffer(o.data);
exports.isPrepare = isPrepare;
const isFulfill = (o) => isObject(o) &&
    Buffer.isBuffer(o.fulfillment) &&
    o.fulfillment.byteLength === 32 &&
    Buffer.isBuffer(o.data);
exports.isFulfill = isFulfill;
const isReject = (o) => isObject(o) &&
    typeof o.code === 'string' &&
    ((0, address_1.isValidIlpAddress)(o.triggeredBy) || o.triggeredBy === '') &&
    typeof o.message === 'string' &&
    Buffer.isBuffer(o.data);
exports.isReject = isReject;
const isIlpError = (o) => isObject(o) &&
    typeof o.message === 'string' &&
    typeof o.ilpErrorCode === 'string' &&
    ['string', 'undefined'].includes(typeof o.ilpErrorMessage) &&
    (typeof o.ilpErrorData === 'undefined' || Buffer.isBuffer(o.ilpErrorData));
exports.isIlpError = isIlpError;
const serializeIlpFulfill = (json) => {
    (0, assert_1.default)(Buffer.isBuffer(json.fulfillment) && json.fulfillment.length === 32, 'fulfillment must be a 32-byte buffer');
    (0, assert_1.default)(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer');
    const contentSize = 32 + oer_utils_1.Predictor.measureVarOctetString(json.data.length);
    const envelopeSize = 1 + oer_utils_1.Predictor.measureVarOctetString(contentSize);
    const envelope = new oer_utils_1.Writer(envelopeSize);
    envelope.writeUInt8(IlpPacketType.Fulfill);
    const content = envelope.createVarOctetString(contentSize);
    content.write(json.fulfillment);
    content.writeVarOctetString(json.data);
    return envelope.getBuffer();
};
exports.serializeIlpFulfill = serializeIlpFulfill;
const deserializeIlpFulfill = (binary) => {
    const { type, contents } = (0, exports.deserializeEnvelope)(binary);
    if (type !== IlpPacketType.Fulfill) {
        throw new Error('Packet has incorrect type');
    }
    const reader = oer_utils_1.Reader.from(contents);
    const fulfillment = reader.read(32);
    const data = reader.readVarOctetString();
    return {
        fulfillment,
        data,
    };
};
exports.deserializeIlpFulfill = deserializeIlpFulfill;
const ILP_ERROR_CODE_LENGTH = 3;
const EMPTY_BUFFER = Buffer.alloc(0);
const serializeIlpReject = (json) => {
    (0, assert_1.default)(json.code && typeof json.code === 'string', 'code must be a string');
    (0, assert_1.default)(typeof json.triggeredBy === 'string', 'triggeredBy must be a string');
    (0, assert_1.default)(typeof json.message === 'string', 'message must be a string');
    (0, assert_1.default)(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer');
    const codeBuffer = Buffer.from(json.code, 'ascii');
    if (codeBuffer.length !== ILP_ERROR_CODE_LENGTH) {
        throw new Error('ILP error codes must be three bytes long, received: ' + json.code);
    }
    const triggeredBy = Buffer.from(json.triggeredBy, 'ascii');
    const message = Buffer.from(json.message, 'utf8');
    const data = json.data || EMPTY_BUFFER;
    const contentSize = ILP_ERROR_CODE_LENGTH +
        oer_utils_1.Predictor.measureVarOctetString(triggeredBy.length) +
        oer_utils_1.Predictor.measureVarOctetString(message.length) +
        oer_utils_1.Predictor.measureVarOctetString(data.length);
    const envelopeSize = 1 + oer_utils_1.Predictor.measureVarOctetString(contentSize);
    const envelope = new oer_utils_1.Writer(envelopeSize);
    envelope.writeUInt8(IlpPacketType.Reject);
    const content = envelope.createVarOctetString(contentSize);
    content.write(codeBuffer);
    content.writeVarOctetString(triggeredBy);
    content.writeVarOctetString(message);
    content.writeVarOctetString(data);
    return envelope.getBuffer();
};
exports.serializeIlpReject = serializeIlpReject;
const deserializeIlpReject = (binary) => {
    const { type, contents } = (0, exports.deserializeEnvelope)(binary);
    if (type !== IlpPacketType.Reject) {
        throw new Error('Packet has incorrect type');
    }
    const reader = oer_utils_1.Reader.from(contents);
    const code = reader.read(ILP_ERROR_CODE_LENGTH).toString('ascii');
    const triggeredBy = reader.readVarOctetString().toString('ascii');
    if (!(0, address_1.isValidIlpAddress)(triggeredBy) && triggeredBy !== '') {
        throw new Error('Invalid triggeredBy ILP address');
    }
    const message = reader.readVarOctetString().toString('utf8');
    const data = reader.readVarOctetString();
    return {
        code,
        triggeredBy,
        message,
        data,
    };
};
exports.deserializeIlpReject = deserializeIlpReject;
const serializeIlpPacket = (obj) => {
    switch (obj.type) {
        case Type.TYPE_ILP_PREPARE:
            return (0, exports.serializeIlpPrepare)(obj.data);
        case Type.TYPE_ILP_FULFILL:
            return (0, exports.serializeIlpFulfill)(obj.data);
        case Type.TYPE_ILP_REJECT:
            return (0, exports.serializeIlpReject)(obj.data);
        default:
            throw new Error('Object has invalid type');
    }
};
exports.serializeIlpPacket = serializeIlpPacket;
const deserializeIlpPacket = (binary) => {
    if (binary[0] === Type.TYPE_ILP_PREPARE) {
        return {
            type: binary[0],
            typeString: 'ilp_prepare',
            data: (0, exports.deserializeIlpPrepare)(binary),
        };
    }
    else if (binary[0] === Type.TYPE_ILP_FULFILL) {
        return {
            type: binary[0],
            typeString: 'ilp_fulfill',
            data: (0, exports.deserializeIlpFulfill)(binary),
        };
    }
    else if (binary[0] === Type.TYPE_ILP_REJECT) {
        return {
            type: binary[0],
            typeString: 'ilp_reject',
            data: (0, exports.deserializeIlpReject)(binary),
        };
    }
    else {
        throw new Error('Packet has invalid type');
    }
};
exports.deserializeIlpPacket = deserializeIlpPacket;
const deserializeIlpReply = (data) => data[0] === IlpPacketType.Fulfill ? (0, exports.deserializeIlpFulfill)(data) : (0, exports.deserializeIlpReject)(data);
exports.deserializeIlpReply = deserializeIlpReply;
const serializeIlpReply = (packet) => (0, exports.isFulfill)(packet) ? (0, exports.serializeIlpFulfill)(packet) : (0, exports.serializeIlpReject)(packet);
exports.serializeIlpReply = serializeIlpReply;
const errorToReject = (address, error) => {
    return (0, exports.serializeIlpReject)((0, exports.errorToIlpReject)(address, error));
};
exports.errorToReject = errorToReject;
const errorToIlpReject = (address, error) => {
    return {
        code: error.ilpErrorCode || 'F00',
        triggeredBy: address,
        message: error.ilpErrorMessage || error.message || '',
        data: error.ilpErrorData || Buffer.alloc(0),
    };
};
exports.errorToIlpReject = errorToIlpReject;
//# sourceMappingURL=index.js.map