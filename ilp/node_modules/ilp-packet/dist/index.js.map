{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { Predictor, Reader, Writer } from 'oer-utils'\nimport { dateToInterledgerTime, interledgerTimeToDate, INTERLEDGER_TIME_LENGTH } from './utils/date'\nimport assert from 'assert'\nimport { IlpAddress, isValidIlpAddress } from './utils/address'\nimport Long from 'long'\nimport * as errors from './errors'\n\nexport const Errors = errors\n\nexport { IlpAddress, isValidIlpAddress }\nexport { getScheme, IlpAddressScheme } from './utils/address'\n\nexport { IlpErrorCode, IlpErrorCode as IlpError, BaseIlpError as IlpErrorClass } from './errors'\n\nexport const isCanonicalIlpRejectCode = (o: unknown): o is errors.IlpErrorCode =>\n  typeof o === 'string' && Object.values<string>(errors.IlpErrorCode).includes(o)\n\nexport enum Type {\n  TYPE_ILP_PREPARE = 12,\n  TYPE_ILP_FULFILL = 13,\n  TYPE_ILP_REJECT = 14,\n}\n\nexport enum IlpPacketType {\n  Prepare = 12,\n  Fulfill = 13,\n  Reject = 14,\n}\n\nexport const deserializeEnvelope = (\n  binary: Buffer\n): {\n  type: number\n  contents: Buffer\n} => {\n  const envelopeReader = Reader.from(binary)\n  const type = envelopeReader.readUInt8Number()\n  const contents = envelopeReader.readVarOctetString()\n\n  return { type, contents }\n}\n\nexport type IlpPacket =\n  | {\n      type: Type.TYPE_ILP_PREPARE\n      typeString?: 'ilp_prepare'\n      data: IlpPrepare\n    }\n  | {\n      type: Type.TYPE_ILP_FULFILL\n      typeString?: 'ilp_fulfill'\n      data: IlpFulfill\n    }\n  | {\n      type: Type.TYPE_ILP_REJECT\n      typeString?: 'ilp_reject'\n      data: IlpReject\n    }\n\nexport interface IlpPrepare {\n  amount: string\n  executionCondition: Buffer\n  expiresAt: Date\n  destination: string\n  data: Buffer\n}\n\nexport const serializeIlpPrepare = (json: IlpPrepare): Buffer => {\n  assert(\n    json.amount && typeof (json as Partial<IlpPrepare>).amount === 'string',\n    'amount must be a string'\n  )\n  assert(\n    Buffer.isBuffer(json.executionCondition) && json.executionCondition.length === 32,\n    'executionCondition must be a 32-byte buffer'\n  )\n  assert(json.expiresAt && json.expiresAt instanceof Date, 'expiresAt must be a Date')\n  assert(typeof (json as Partial<IlpPrepare>).destination === 'string', 'destination is required')\n  assert(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer')\n\n  const expiresAt = Buffer.from(dateToInterledgerTime(json.expiresAt), 'ascii')\n  const destination = Buffer.from(json.destination, 'ascii')\n\n  const contentSize =\n    8 + // amount\n    INTERLEDGER_TIME_LENGTH +\n    32 + // executionCondition\n    Predictor.measureVarOctetString(destination.length) +\n    Predictor.measureVarOctetString(json.data.length)\n  const envelopeSize = 1 + Predictor.measureVarOctetString(contentSize)\n\n  const envelope = new Writer(envelopeSize)\n  envelope.writeUInt8(IlpPacketType.Prepare)\n\n  const content = envelope.createVarOctetString(contentSize)\n  content.writeUInt64(json.amount)\n  content.write(expiresAt)\n  content.write(json.executionCondition)\n  content.writeVarOctetString(destination)\n  content.writeVarOctetString(json.data)\n\n  return envelope.getBuffer()\n}\n\nexport const deserializeIlpPrepare = (binary: Buffer): IlpPrepare => {\n  const { type, contents } = deserializeEnvelope(binary)\n\n  if (type !== IlpPacketType.Prepare) {\n    throw new Error('Packet has incorrect type')\n  }\n\n  const reader = Reader.from(contents)\n  const amount = reader.readUInt64()\n  const expiresAt = interledgerTimeToDate(reader.read(INTERLEDGER_TIME_LENGTH).toString('ascii'))\n  const executionCondition = reader.read(32)\n  const destination = reader.readVarOctetString().toString('ascii')\n  if (!isValidIlpAddress(destination)) {\n    throw new Error('Packet has invalid destination address')\n  }\n  const data = reader.readVarOctetString()\n\n  return {\n    amount,\n    executionCondition,\n    expiresAt,\n    destination,\n    data,\n  }\n}\n\nexport interface IlpFulfill {\n  fulfillment: Buffer\n  data: Buffer\n}\n\nconst isUInt64 = (o: string): boolean => {\n  try {\n    const l = Long.fromString(o, true)\n    return l.toString() === o\n  } catch (_) {\n    return false // `Long.fromString` throws if empty, misplaced hyphen, etc.\n  }\n}\n\nexport const isIlpReply = (o: unknown): o is IlpReply => isFulfill(o) || isReject(o)\n\nconst isObject = (o: unknown): o is Record<string, unknown> => typeof o === 'object' && o !== null\n\nexport const isPrepare = (o: unknown): o is IlpPrepare =>\n  isObject(o) &&\n  typeof o.amount === 'string' &&\n  isUInt64(o.amount) && // All ILP packet amounts must be within u64 range or should fail serialization\n  o.expiresAt instanceof Date &&\n  !Number.isNaN(o.expiresAt.getTime()) && // Check date instance is valid\n  isValidIlpAddress(o.destination) &&\n  Buffer.isBuffer(o.executionCondition) &&\n  o.executionCondition.byteLength === 32 &&\n  Buffer.isBuffer(o.data)\n\nexport const isFulfill = (o: unknown): o is IlpFulfill =>\n  isObject(o) &&\n  Buffer.isBuffer(o.fulfillment) &&\n  o.fulfillment.byteLength === 32 &&\n  Buffer.isBuffer(o.data)\n\nexport const isReject = (o: unknown): o is IlpReject =>\n  isObject(o) &&\n  typeof o.code === 'string' &&\n  (isValidIlpAddress(o.triggeredBy) || o.triggeredBy === '') && // ILP address or empty string\n  typeof o.message === 'string' &&\n  Buffer.isBuffer(o.data)\n\nexport const isIlpError = (o: unknown): o is errors.BaseIlpError =>\n  isObject(o) &&\n  typeof o.message === 'string' &&\n  typeof o.ilpErrorCode === 'string' &&\n  ['string', 'undefined'].includes(typeof o.ilpErrorMessage) &&\n  (typeof o.ilpErrorData === 'undefined' || Buffer.isBuffer(o.ilpErrorData))\n\nexport const serializeIlpFulfill = (json: IlpFulfill): Buffer => {\n  assert(\n    Buffer.isBuffer(json.fulfillment) && json.fulfillment.length === 32,\n    'fulfillment must be a 32-byte buffer'\n  )\n  assert(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer')\n\n  const contentSize = 32 + Predictor.measureVarOctetString(json.data.length)\n  const envelopeSize = 1 + Predictor.measureVarOctetString(contentSize)\n\n  const envelope = new Writer(envelopeSize)\n  envelope.writeUInt8(IlpPacketType.Fulfill)\n\n  const content = envelope.createVarOctetString(contentSize)\n  content.write(json.fulfillment)\n  content.writeVarOctetString(json.data)\n\n  return envelope.getBuffer()\n}\n\nexport const deserializeIlpFulfill = (binary: Buffer): IlpFulfill => {\n  const { type, contents } = deserializeEnvelope(binary)\n\n  if (type !== IlpPacketType.Fulfill) {\n    throw new Error('Packet has incorrect type')\n  }\n\n  const reader = Reader.from(contents)\n  const fulfillment = reader.read(32)\n  const data = reader.readVarOctetString()\n\n  return {\n    fulfillment,\n    data,\n  }\n}\n\nconst ILP_ERROR_CODE_LENGTH = 3\n\nexport interface IlpReject {\n  code: string\n  triggeredBy: string\n  message: string\n  data: Buffer\n}\n\nconst EMPTY_BUFFER = Buffer.alloc(0)\n\nexport const serializeIlpReject = (json: IlpReject): Buffer => {\n  assert(\n    json.code && typeof (json as Partial<IlpReject>).code === 'string',\n    'code must be a string'\n  )\n  assert(\n    typeof (json as Partial<IlpReject>).triggeredBy === 'string',\n    'triggeredBy must be a string'\n  )\n  assert(typeof (json as Partial<IlpReject>).message === 'string', 'message must be a string')\n  assert(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer')\n\n  // Convert code to buffer to ensure we are counting bytes, not UTF8 characters\n  const codeBuffer = Buffer.from(json.code, 'ascii')\n  if (codeBuffer.length !== ILP_ERROR_CODE_LENGTH) {\n    throw new Error('ILP error codes must be three bytes long, received: ' + json.code)\n  }\n\n  const triggeredBy = Buffer.from(json.triggeredBy, 'ascii')\n  const message = Buffer.from(json.message, 'utf8')\n  const data = json.data || EMPTY_BUFFER\n\n  const contentSize =\n    ILP_ERROR_CODE_LENGTH +\n    Predictor.measureVarOctetString(triggeredBy.length) +\n    Predictor.measureVarOctetString(message.length) +\n    Predictor.measureVarOctetString(data.length)\n  const envelopeSize = 1 + Predictor.measureVarOctetString(contentSize)\n\n  const envelope = new Writer(envelopeSize)\n  envelope.writeUInt8(IlpPacketType.Reject)\n\n  const content = envelope.createVarOctetString(contentSize)\n  content.write(codeBuffer)\n  content.writeVarOctetString(triggeredBy)\n  content.writeVarOctetString(message)\n  content.writeVarOctetString(data)\n\n  return envelope.getBuffer()\n}\n\nexport const deserializeIlpReject = (binary: Buffer): IlpReject => {\n  const { type, contents } = deserializeEnvelope(binary)\n\n  if (type !== IlpPacketType.Reject) {\n    throw new Error('Packet has incorrect type')\n  }\n\n  const reader = Reader.from(contents)\n\n  const code = reader.read(ILP_ERROR_CODE_LENGTH).toString('ascii')\n\n  const triggeredBy = reader.readVarOctetString().toString('ascii')\n  if (!isValidIlpAddress(triggeredBy) && triggeredBy !== '') {\n    throw new Error('Invalid triggeredBy ILP address')\n  }\n\n  const message = reader.readVarOctetString().toString('utf8')\n  const data = reader.readVarOctetString()\n\n  return {\n    code,\n    triggeredBy,\n    message,\n    data,\n  }\n}\n\nexport const serializeIlpPacket = (obj: IlpPacket) => {\n  switch (obj.type) {\n    case Type.TYPE_ILP_PREPARE:\n      return serializeIlpPrepare(obj.data)\n    case Type.TYPE_ILP_FULFILL:\n      return serializeIlpFulfill(obj.data)\n    case Type.TYPE_ILP_REJECT:\n      return serializeIlpReject(obj.data)\n    default:\n      throw new Error('Object has invalid type')\n  }\n}\n\nexport const deserializeIlpPacket = (binary: Buffer): IlpPacket => {\n  if (binary[0] === Type.TYPE_ILP_PREPARE) {\n    return {\n      type: binary[0],\n      typeString: 'ilp_prepare',\n      data: deserializeIlpPrepare(binary),\n    }\n  } else if (binary[0] === Type.TYPE_ILP_FULFILL) {\n    return {\n      type: binary[0],\n      typeString: 'ilp_fulfill',\n      data: deserializeIlpFulfill(binary),\n    }\n  } else if (binary[0] === Type.TYPE_ILP_REJECT) {\n    return {\n      type: binary[0],\n      typeString: 'ilp_reject',\n      data: deserializeIlpReject(binary),\n    }\n  } else {\n    throw new Error('Packet has invalid type')\n  }\n}\n\nexport type IlpPacketHander = (packet: IlpPrepare) => Promise<IlpReply>\n\nexport type IlpAny = IlpPrepare | IlpFulfill | IlpReject\n\nexport type IlpReply = IlpFulfill | IlpReject\n\nexport const deserializeIlpReply = (data: Buffer): IlpReply =>\n  data[0] === IlpPacketType.Fulfill ? deserializeIlpFulfill(data) : deserializeIlpReject(data)\n\nexport const serializeIlpReply = (packet: IlpReply): Buffer =>\n  isFulfill(packet) ? serializeIlpFulfill(packet) : serializeIlpReject(packet)\n\nexport const errorToReject = (address: string, error: errors.BaseIlpError): Buffer => {\n  return serializeIlpReject(errorToIlpReject(address, error))\n}\n\nexport const errorToIlpReject = (address: string, error: errors.BaseIlpError): IlpReject => {\n  return {\n    code: error.ilpErrorCode || 'F00',\n    triggeredBy: address,\n    message: error.ilpErrorMessage || error.message || '',\n    data: error.ilpErrorData || Buffer.alloc(0),\n  }\n}\n"]}