{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import * as assert from 'assert'\nimport * as crypto from 'crypto'\nimport * as Debug from 'debug'\nimport * as WebSocket from 'ws'\nimport * as http from 'http'\nimport * as https from 'https'\nimport { WebSocketReconnector, WebSocketConstructor } from './ws-reconnect'\nimport { EventEmitter2, Listener } from 'eventemitter2'\nimport { protocolDataToIlpAndCustom, ilpAndCustomToProtocolData } from './protocol-data-converter'\n\nconst BtpPacket = require('btp-packet')\n\nconst debug = require('ilp-logger')('ilp-plugin-btp')\n\ntype DataHandler = (data: Buffer) => Promise<Buffer>\ntype MoneyHandler = (amount: string) => Promise<void>\n\nenum ReadyState {\n  INITIAL = 0,\n  CONNECTING = 1,\n  CONNECTED = 2,\n  DISCONNECTED = 3,\n  READY_TO_EMIT = 4\n}\n\nconst DEFAULT_TIMEOUT = 35000\nconst namesToCodes = {\n  'UnreachableError': 'T00',\n  'NotAcceptedError': 'F00',\n  'InvalidFieldsError': 'F01',\n  'TransferNotFoundError': 'F03',\n  'InvalidFulfillmentError': 'F04',\n  'DuplicateIdError': 'F05',\n  'AlreadyRolledBackError': 'F06',\n  'AlreadyFulfilledError': 'F07',\n  'InsufficientBalanceError': 'F08'\n}\n\nconst toBrowserSafeURL = (btpUrl: string): URL => {\n  if (!btpUrl.startsWith('btp+')) {\n    throw new Error('server must start with \"btp+\". server=' + btpUrl)\n  }\n\n  return new URL(btpUrl.substring(4))\n}\n\n/**\n * Returns BTP error code as defined by the BTP ASN.1 spec.\n */\nfunction jsErrorToBtpError (e: Error) {\n  const name: string = e.name || 'NotAcceptedError'\n  const code: string = namesToCodes[name] || 'F00'\n\n  return {\n    code,\n    name,\n    triggeredAt: new Date(),\n    data: JSON.stringify({ message: e.message })\n  }\n}\n\nconst ILP_PACKET_TYPES = {\n  12: 'ilp-prepare',\n  13: 'ilp-fulfill',\n  14: 'ilp-reject'\n}\n\n/**\n * Converts BTP sub protocol data from json/plain text/octet stream to string.\n */\nfunction subProtocolToString (data: BtpSubProtocol): string {\n  let stringData\n\n  switch (data.contentType) {\n    case BtpPacket.MIME_APPLICATION_OCTET_STREAM:\n      stringData = data.data.toString('base64')\n      break\n    case BtpPacket.MIME_APPLICATION_JSON:\n    case BtpPacket.MIME_TEXT_PLAIN_UTF8:\n      stringData = data.data.toString('utf8')\n      break\n  }\n\n  return `${data.protocolName}=${stringData}`\n}\n\n/**\n * Goes through all the sub protocols in the packet data of a BTP packet and\n * returns a protocol map of each sub protocol with the key as the protocol\n * name and value as a string-form protocol object. Calls\n * `subProtocolToString(data)` to convert the value to a string.\n */\nfunction generatePacketDataTracer (packetData: BtpPacketData) {\n  return {\n    toString: () => {\n      try {\n        return packetData.protocolData.map(data => {\n          switch (data.protocolName) {\n            case 'ilp':\n              return ILP_PACKET_TYPES[data.data[0]] || ('ilp-' + data.data[0])\n            default:\n              return subProtocolToString(data)\n          }\n        }).join(';')\n      } catch (err) {\n        return 'serialization error. err=' + err.stack\n      }\n    }\n  }\n}\n\nexport interface BtpPacket {\n  requestId: number\n  type: number\n  data: BtpPacketData\n}\n\nexport interface BtpPacketData {\n  protocolData: Array<BtpSubProtocol>\n  amount?: string\n  code?: string\n  name?: string\n  triggeredAt?: Date\n  data?: string\n}\n\nexport interface BtpSubProtocol {\n  protocolName: string\n  contentType: number\n  data: Buffer\n}\n\n/**\n * Constructor options for a BTP plugin. The 'Instance Management' section of\n * the RFC-24 indicates that every ledger plugin accepts an opts object, and\n * an optional api denoted as 'PluginServices.' This is the opts object.\n */\nexport interface IlpPluginBtpConstructorOptions {\n  server?: string,\n  listener?: {\n    port: number,\n    secret: string,\n    wsOpts?: WebSocket.ServerOptions\n  },\n  reconnectInterval?: number\n  reconnectIntervals?: Array<number>\n  reconnectClearTryTimeout?: number\n  responseTimeout?: number\n  btpAccount?: string\n  btpToken?: string\n  btpAuthFlags?: Record<string, string | Buffer | Object>\n}\n\nexport interface WebSocketServerConstructor {\n  new (opts: WebSocket.ServerOptions): WebSocket.Server\n}\n\n/**\n * This is the optional api, or 'PluginServices' interface, that is passed\n * into the ledger plugin constructor as defined in RFC-24. In this case\n * the api exposes 3 modules.\n */\nexport interface IlpPluginBtpConstructorModules {\n  log?: any\n  WebSocket?: WebSocketConstructor\n  WebSocketServer?: WebSocketServerConstructor\n}\n\n/**\n * Abstract base class for building BTP-based ledger plugins.\n *\n * This class takes care of most of the work translating between BTP and the\n * ledger plugin interface (LPI).\n *\n * You need to implement:\n *\n * `sendMoney (amount)`, handleMoney `(from, btpPacket)`\n *\n * The `from` field is set to null in all the methods here. It is present in\n * order to make it possible to write multi account plugins (plugins with an\n * internal connector which understand ILP).\n *\n * If any work must be done on disconnect, implement _disconnect instead of\n * overriding this.disconnect. This will ensure that the connection is cleaned\n * up properly.\n *\n * If any work must be done on connect, implement _connect. You can also\n * rewrite connect, but then disconnect and handleOutgoingBtpPacket should also\n * be overridden.\n *\n * Instead, you need to implement _handleOutgoingBtpPacket(to, btpPacket) which\n * returns a Promise. `to` is the ILP address of the destination peer and\n * `btpPacket` is the BTP packet as a JavaScript object.\n *\n * You can call _handleIncomingBtpPacket(from, btpPacket) to trigger all the\n * necessary LPI events in response to an incoming BTP packet. `from` is the\n * ILP address of the peer and `btpPacket` is the parsed BTP packet.\n */\nexport default class AbstractBtpPlugin extends EventEmitter2 {\n  public static version = 2\n\n  private _reconnectInterval?: number\n  private _reconnectIntervals?: Array<number>\n  private _reconnectClearTryTimeout?: number\n  private _responseTimeout: number\n\n  protected _dataHandler?: DataHandler\n  protected _moneyHandler?: MoneyHandler\n  private _readyState: ReadyState = ReadyState.INITIAL\n  protected _log: any\n  private WebSocket: WebSocketConstructor\n  private WebSocketServer: WebSocketServerConstructor\n\n  /**\n   * Specify for a BTP instance that is acting as a server.\n   */\n  private _listener?: {\n    port: number,\n    secret: string\n    wsOpts?: WebSocket.ServerOptions\n  }\n  private _httpServer: http.Server | https.Server\n  private _listenerSecret?: Buffer\n  protected _wss: WebSocket.Server | null = null\n  private _incomingWs?: WebSocket\n\n  /**\n   * Specify for a BTP instance that is acting as a client.\n   */\n  private _server?: string\n  private _btpToken?: string\n  private _btpAccount?: string\n  private _flags?: Record<string, string | Buffer | Object>\n\n  /**\n   * Refer to `ws-reconnect` module.\n   */\n  private _ws?: WebSocketReconnector\n\n  constructor (options: IlpPluginBtpConstructorOptions, modules?: IlpPluginBtpConstructorModules) {\n    super()\n\n    this._reconnectInterval = options.reconnectInterval // optional\n    this._reconnectIntervals = options.reconnectIntervals // optional\n    this._reconnectClearTryTimeout = options.reconnectClearTryTimeout // optional\n    this._responseTimeout = options.responseTimeout || DEFAULT_TIMEOUT\n    this._listener = options.listener\n    this._server = options.server\n\n    if (this._listener) {\n      this._listenerSecret = Buffer.from(this._listener.secret, 'utf8')\n      this._listener.wsOpts = this._listener.wsOpts || { port: this._listener.port }\n      if (this._listener.wsOpts.server) {\n        this._httpServer = this._listener.wsOpts.server\n      }\n    }\n\n    if (this._server) {\n      const parsedBtpUri = toBrowserSafeURL(this._server)\n      const parsedAccount = parsedBtpUri.username\n      const parsedToken = parsedBtpUri.password\n\n      if ((parsedAccount || parsedToken) && (options.btpAccount || options.btpToken)) {\n        throw new Error('account/token must be passed in via constructor or uri, but not both')\n      }\n\n      this._btpToken = parsedToken || options.btpToken || ''\n      this._btpAccount = parsedAccount || options.btpAccount || ''\n      this._flags = options.btpAuthFlags\n    }\n\n    modules = modules || {}\n    this._log = modules.log || debug\n    this._log.trace = this._log.trace || Debug(this._log.debug.namespace + ':trace')\n    this.WebSocket = modules.WebSocket || WebSocket\n    this.WebSocketServer = modules.WebSocketServer || WebSocket.Server\n  }\n\n  // Required for different _connect signature in mini-accounts and its subclasses\n  /* tslint:disable-next-line:no-empty */\n  protected async _connect (...opts: any[]): Promise<void> {}\n  /* tslint:disable-next-line:no-empty */\n  protected async _disconnect (): Promise<void> {}\n\n  /**\n   * Connect to another BTP-based ledger plugin if the instance is not already\n   * connected/connecting to another plugin.\n   *\n   * **If the BTP instance is acting as a server:**\n   *\n   * It creates a new server on the specified `port` from `this.listener`.\n   * It creates an event listener for `connection`. When a connection\n   * is established, listeners for `close`, `error`, and `message` are\n   * added. The listeners for close and error call `emitDisconnect()`.\n   *\n   * There are two listeners for `message` events. First:\n   * Uses socket.once to add a one time listener for the event. The\n   * listener is only invoked the first time and then removed. This is\n   * because the auth message only needs to occur once. We do not want\n   * this event to be triggered on subsequent messages.\n   *\n   * Call `validateAuthPacket()`, and close any other incoming\n   * websocket connections (if present) by calling `closeIncomingSocket`. Return a\n   * response containing the request id if the auth packet is valid.\n   *\n   * Otherwise, if an auth packet fails validation, return a BTP error\n   * response over the connection and close.\n   *\n   * Finally, add a listener to accept subsequent incoming websocket\n   * messages and handle them accordingly. Calls\n   * `handleIncomingWsMessage(socket)`.\n   *\n   * **If the BTP instance is acting as a client:**\n   *\n   * Generate the BTP URL with username, token, and the server uri.\n   * Register listener for opening connection, first time connect, and\n   * incoming messages. Need to register the on open listener before actually\n   * opening a connection. The reason this is not a 'once' listener is\n   * because the client might have to reconnect if the connection fails (as\n   * specified in ws-reconnect) and thus the listener must be active. The `open`\n   * listener sends the BTP auth packet to the server using the `call` function\n   * (sends request, sets a timeout to wait for response).\n   *\n   * Open the connection, and register listeners for `close`, `message`. If the\n   * connection is successfully established, resolve. Otherwise if\n   * closed/disconnected error.\n   *\n   * **Important:** now call `this._connect()` which will be overriden in\n   * subsequent plugins to add ledger functionality after the connection has\n   * been established.\n   */\n  async connect () {\n    if (this._readyState > ReadyState.INITIAL) {\n      return\n    }\n\n    this._readyState = ReadyState.CONNECTING\n\n    /* Server logic. */\n    if (this._listener) {\n      if (this._httpServer) {\n        this._httpServer.listen(this._listener.port)\n      }\n      const wss = this._wss = new (this.WebSocketServer)({ ...this._listener.wsOpts })\n      this._incomingWs = undefined\n\n      wss.on('connection', (socket: WebSocket) => {\n        this._log.info('got connection')\n        let authPacket: BtpPacket\n\n        socket.on('close', (code: number) => {\n          this._log.info('incoming websocket closed. code=' + code)\n          this._emitDisconnect()\n        })\n\n        socket.on('error', (err: Error) => {\n          this._log.debug('incoming websocket error. error=', err)\n          this._emitDisconnect()\n        })\n\n        socket.once('message', async (binaryAuthMessage: WebSocket.Data) => {\n          try {\n            authPacket = BtpPacket.deserialize(binaryAuthMessage)\n            this._log.trace('got auth packet. packet=%j', authPacket)\n            this._validateAuthPacket(authPacket)\n            if (this._incomingWs) {\n              this._closeIncomingSocket(this._incomingWs, authPacket)\n            }\n            this._incomingWs = socket\n            socket.send(BtpPacket.serializeResponse(authPacket.requestId, []))\n          } catch (err) {\n            this._incomingWs = undefined\n            if (authPacket) {\n              const errorResponse = BtpPacket.serializeError({\n                code: 'F00',\n                name: 'NotAcceptedError',\n                data: err.message,\n                triggeredAt: new Date().toISOString()\n              }, authPacket.requestId, [])\n              socket.send(errorResponse)\n            }\n            socket.close()\n            return\n          }\n\n          this._log.trace('connection authenticated')\n          socket.on('message', this._handleIncomingWsMessage.bind(this, socket))\n          this._emitConnect(authPacket)\n        })\n      })\n      this._log.info(`listening for BTP connections on ${this._listener.port}`)\n    }\n\n    /* Client logic. */\n    if (this._server) {\n      const parsedBtpUri = toBrowserSafeURL(this._server)\n      const account = this._btpAccount || ''\n      const token = this._btpToken || ''\n\n      this._ws = new WebSocketReconnector({\n        WebSocket: this.WebSocket,\n        intervals: this._reconnectIntervals,\n        interval: this._reconnectInterval,\n        clearTryTimeout: this._reconnectClearTryTimeout\n      })\n\n      const protocolMap = Object.assign({\n        auth: Buffer.from([]),\n        auth_username: account,\n        auth_token: token\n      }, this._flags)\n\n      this._ws.on('open', async () => {\n        this._log.trace('connected to server')\n        this._call('', {\n          type: BtpPacket.TYPE_MESSAGE,\n          requestId: await _requestId(),\n          data: { protocolData: ilpAndCustomToProtocolData({ protocolMap }) }\n        }).then(() => {\n          this._emitConnect()\n        }).catch((err) => {\n          this._log.error('error authenticating btp connection', err.message)\n        })\n      })\n\n      // CAUTION: Do not delete the following two lines, they have the side-effect\n      // of removing the 'user@pass:' part from parsedBtpUri.toString()!\n      parsedBtpUri.username = ''\n      parsedBtpUri.password = ''\n\n      await this._ws.open(parsedBtpUri.toString())\n\n      this._ws.on('close', () => this._emitDisconnect())\n      this._ws.on('message', this._handleIncomingWsMessage.bind(this, this._ws))\n    }\n\n    const flags = await new Promise((resolve, reject) => {\n      const onDisconnect = () => {\n        if (this._ws) this._ws.close()\n        reject(new Error('connection aborted'))\n      }\n      this.once('disconnect', onDisconnect)\n      this.once('_first_time_connect', (authPacket?: BtpPacket) => {\n        this.removeListener('disconnect', onDisconnect)\n        resolve(authPacket ? protocolDataToIlpAndCustom(authPacket.data).protocolMap : {})\n      })\n    })\n\n    /* To be overriden. */\n    await this._connect(flags)\n\n    this._readyState = ReadyState.READY_TO_EMIT\n    this._emitConnect()\n  }\n\n  /**\n   * For when there is an existing websocket connection and a new\n   * connection is opened. Removes all listeners from previous connection and\n   * sends an error to the user on the old socket (with the new request ID).\n   */\n  _closeIncomingSocket (socket: WebSocket, authPacket: BtpPacket) {\n    socket.removeAllListeners()\n    socket.once('message', async (data: WebSocket.Data) => {\n      try {\n        socket.send(BtpPacket.serializeError({\n          code: 'F00',\n          name: 'NotAcceptedError',\n          data: 'This connection has been ended because the user has opened a new connection',\n          triggeredAt: new Date().toISOString()\n        }, authPacket.requestId, []))\n      } catch (e) {\n        this._log.error('error responding on closed socket', e)\n      }\n      socket.close()\n    })\n  }\n\n  /**\n   * Close client/server and emit disconnect.\n   *\n   * **Important**: calls `this_disconnect` which is meant to be overriden by\n   * plugins that extend BTP to add additional (e.g. ledger) functionality on\n   * disconnect.\n   */\n  async disconnect () {\n    this._emitDisconnect()\n\n    /* To be overriden. */\n    await this._disconnect()\n\n    if (this._ws) this._ws.close()\n    if (this._incomingWs) {\n      this._incomingWs.close()\n      this._incomingWs = undefined\n    }\n    if (this._wss) {\n      this._wss.close()\n      if (this._httpServer) {\n        this._httpServer.close()\n      }\n      this._wss = null\n    }\n  }\n\n  isConnected () {\n    return this._readyState === ReadyState.CONNECTED\n  }\n\n  /**\n   * Deserialize incoming websocket message and call `handleIncomingBtpPacket`.\n   * If error in handling btp packet, call `handleOutgoingBtpPacket` and send\n   * the error through the socket.\n   */\n  async _handleIncomingWsMessage (ws: WebSocket, binaryMessage: WebSocket.Data) {\n    let btpPacket: BtpPacket\n    try {\n      btpPacket = BtpPacket.deserialize(binaryMessage)\n    } catch (err) {\n      this._log.error('deserialization error:', err)\n      ws.close()\n      return\n    }\n\n    try {\n      await this._handleIncomingBtpPacket('', btpPacket)\n    } catch (err) {\n      this._log.debug(`Error processing BTP packet of type ${btpPacket.type}: `, err)\n      const error = jsErrorToBtpError(err)\n      const requestId = btpPacket.requestId\n      const { code, name, triggeredAt, data } = error\n\n      await this._handleOutgoingBtpPacket('', {\n        type: BtpPacket.TYPE_ERROR,\n        requestId,\n        data: {\n          code,\n          name,\n          triggeredAt,\n          data,\n          protocolData: []\n        }\n      })\n    }\n  }\n\n  /**\n   * Send Btp data to counterparty. Uses `_call` which sets the proper timer for\n   * expiry on response packets.\n   */\n  async sendData (buffer: Buffer): Promise<Buffer> {\n    const response = await this._call('', {\n      type: BtpPacket.TYPE_MESSAGE,\n      requestId: await _requestId(),\n      data: { protocolData: [{\n        protocolName: 'ilp',\n        contentType: BtpPacket.MIME_APPLICATION_OCTET_STREAM,\n        data: buffer\n      }] }\n    })\n\n    const ilpResponse = response.protocolData\n      .filter(p => p.protocolName === 'ilp')[0]\n\n    return ilpResponse\n      ? ilpResponse.data\n      : Buffer.alloc(0)\n  }\n\n  /**\n   * With no underlying ledger, sendMoney is a no-op.\n   */\n  async sendMoney (amount: string): Promise<void> {\n    /* NO OP */\n  }\n\n  /**\n   * Don't throw errors even if the event handler throws\n   * this is especially important in plugins because\n   * errors can prevent the balance from being updated correctly.\n   */\n  _safeEmit () {\n    try {\n      this.emit.apply(this, arguments)\n    } catch (err) {\n      const errInfo = (typeof err === 'object' && err.stack) ? err.stack : String(err)\n      this._log.error('error in handler for event', arguments, errInfo)\n    }\n  }\n\n  registerDataHandler (handler: DataHandler) {\n    if (this._dataHandler) {\n      throw new Error('requestHandler is already registered')\n    }\n\n    // TODO Is this check required? TypeScript's linter suggests not\n    // tslint:disable-next-line:strict-type-predicates\n    if (typeof handler !== 'function') {\n      throw new Error('requestHandler must be a function')\n    }\n\n    this._log.trace('registering data handler')\n    this._dataHandler = handler\n  }\n\n  deregisterDataHandler () {\n    this._dataHandler = undefined\n  }\n\n  registerMoneyHandler (handler: MoneyHandler) {\n    if (this._moneyHandler) {\n      throw new Error('requestHandler is already registered')\n    }\n\n    // TODO Is this check required? TypeScript's linter suggests not\n    // tslint:disable-next-line:strict-type-predicates\n    if (typeof handler !== 'function') {\n      throw new Error('requestHandler must be a function')\n    }\n\n    this._log.trace('registering money handler')\n    this._moneyHandler = handler\n  }\n\n  deregisterMoneyHandler () {\n    this._moneyHandler = undefined\n  }\n\n  protocolDataToIlpAndCustom (packet: BtpPacketData) {\n    return protocolDataToIlpAndCustom(packet)\n  }\n\n  /**\n   * Converts protocol map to Btp packet. Reference in\n   * procotol-data-converter.ts.\n   */\n  ilpAndCustomToProtocolData (obj: { ilp?: Buffer, custom?: Object, protocolMap?: Record<string, Buffer | string | Object> }) {\n    return ilpAndCustomToProtocolData(obj)\n  }\n\n  /**\n   * Function to send Btp requests with proper timeout for response or error.\n   *\n   * Create a listener for for an incoming Btp response/error. Resolves on\n   * btp response, rejects on btp error. Send an outgoing btp packet (request),\n   * and set a timer. If the timer expires before a response/error is received, time\n   * out. If a response/error is received, `_handleIncomingBtpPacket` emits\n   * `__callback__`, which triggers the aforementioned listener.\n   */\n  protected async _call (to: string, btpPacket: BtpPacket): Promise<BtpPacketData> {\n    const requestId = btpPacket.requestId\n\n    let callback: Listener\n    let timer: NodeJS.Timer\n    const response = new Promise<BtpPacketData>((resolve, reject) => {\n      callback = (type: number, data: BtpPacketData) => {\n        switch (type) {\n          case BtpPacket.TYPE_RESPONSE:\n            resolve(data)\n            clearTimeout(timer)\n            break\n\n          case BtpPacket.TYPE_ERROR:\n            reject(new Error(JSON.stringify(data)))\n            clearTimeout(timer)\n            break\n\n          default:\n            throw new Error('Unknown BTP packet type: ' + type)\n        }\n      }\n      this.once('__callback_' + requestId, callback)\n    })\n\n    await this._handleOutgoingBtpPacket(to, btpPacket)\n\n    const timeout = new Promise<BtpPacketData>((resolve, reject) => {\n      timer = setTimeout(() => {\n        this.removeListener('__callback_' + requestId, callback)\n        reject(new Error(requestId + ' timed out'))\n      }, this._responseTimeout)\n    })\n\n    return Promise.race([\n      response,\n      timeout\n    ])\n  }\n\n  /**\n   * If a response or error packet is received, trigger the callback function\n   * defined in _call (i.e. response/error returned before timing out)\n   * function. Throw error on PREPARE, FULFILL or REJECT packets, because they\n   * are not BTP packets. If TRANSFER or MESSAGE packets are received, invoke\n   * money handler or data handler respectively. Otherwise prepare a response and handle the outgoing BTP\n   * packet. The reason this function does not handle sending back an ERROR\n   * packet in the websocket is because that is defined in the\n   * _handleIncomingWsMessage function.\n   */\n  protected async _handleIncomingBtpPacket (from: string, btpPacket: BtpPacket) {\n    const { type, requestId, data } = btpPacket\n    const typeString = BtpPacket.typeToString(type)\n\n    this._log.trace(`received btp packet. type=${typeString} requestId=${requestId} info=${generatePacketDataTracer(data)}`)\n    let result: Array<BtpSubProtocol>\n    switch (type) {\n      case BtpPacket.TYPE_RESPONSE:\n      case BtpPacket.TYPE_ERROR:\n        this.emit('__callback_' + requestId, type, data)\n        return\n      case BtpPacket.TYPE_PREPARE:\n      case BtpPacket.TYPE_FULFILL:\n      case BtpPacket.TYPE_REJECT:\n        throw new Error('Unsupported BTP packet')\n\n      case BtpPacket.TYPE_TRANSFER:\n        result = await this._handleMoney(from, btpPacket)\n        break\n\n      case BtpPacket.TYPE_MESSAGE:\n        result = await this._handleData(from, btpPacket)\n        break\n\n      default:\n        throw new Error('Unknown BTP packet type')\n    }\n\n    await this._handleOutgoingBtpPacket(from, {\n      type: BtpPacket.TYPE_RESPONSE,\n      requestId,\n      data: { protocolData: result || [] }\n    })\n  }\n\n  /**\n   * Called after receiving btp packet of type message. First convert it to ILP\n   * format, then handle the ILP data with the regsistered data handler, and then convert it back to BTP\n   * structure and send a response. E.g. for prepare, fulfill, and reject packets.\n   */\n  protected async _handleData (from: string, btpPacket: BtpPacket): Promise<Array<BtpSubProtocol>> {\n    const { data } = btpPacket\n    const { ilp } = protocolDataToIlpAndCustom(data) /* Defined in protocol-data-converter.ts. */\n\n    if (!this._dataHandler) {\n      throw new Error('no request handler registered')\n    }\n\n    const response = ilp && await this._dataHandler(ilp)\n    return ilpAndCustomToProtocolData({ ilp: response })\n  }\n\n  /**\n   * Need to fully define on you own.\n   */\n  protected async _handleMoney (from: string, btpPacket: BtpPacket): Promise<Array<BtpSubProtocol>> {\n    throw new Error('No sendMoney functionality is included in this module')\n  }\n\n  /**\n   * Send a BTP packet to a user and wait for the promise to resolve without\n   * error.\n   */\n  protected async _handleOutgoingBtpPacket (to: string, btpPacket: BtpPacket) {\n    const ws = this._ws || this._incomingWs\n\n    const { type, requestId, data } = btpPacket\n    const typeString = BtpPacket.typeToString(type)\n    this._log.trace(`sending btp packet. type=${typeString} requestId=${requestId} info=${generatePacketDataTracer(data)}`)\n\n    try {\n      await new Promise((resolve) => ws!.send(BtpPacket.serialize(btpPacket), resolve))\n    } catch (e) {\n      this._log.error('unable to send btp message to client: ' + e.message, 'btp packet:', JSON.stringify(btpPacket))\n    }\n  }\n\n  /**\n   * If the instance is not already disconnected, change the ReadyState and\n   * emit a disconnect event.\n   */\n  private _emitDisconnect () {\n    if (this._readyState !== ReadyState.DISCONNECTED) {\n      this._readyState = ReadyState.DISCONNECTED\n      this.emit('disconnect')\n    }\n  }\n\n  /**\n   * If the ReadyState is CONNECTING it implies a first time connect, so\n   * accordingly emit that message. Otherwise if the instance has already\n   * registered listeners (i.e. connected before) and is in the appropriate\n   * ready state then emit a normal 'connect' event.\n   */\n  private _emitConnect (authPacket?: BtpPacket) {\n    if (this._readyState === ReadyState.CONNECTING) {\n      this.emit('_first_time_connect', authPacket)\n    } else if (this._readyState === ReadyState.READY_TO_EMIT || this._readyState === ReadyState.DISCONNECTED) {\n      this._readyState = ReadyState.CONNECTED\n      this.emit('connect')\n    }\n  }\n\n  /**\n   * Make sure the auth packet is structured correctly with both an 'auth'\n   * subprotocol and an 'auth token' subprotocol. The auth token needs to match the\n   * secret defined by the server (which should have been given to the client\n   * beforehand.) If the auth token does not pass any of these checks, error.\n   */\n  private _validateAuthPacket (authPacket: BtpPacket): void {\n    assert.strictEqual(authPacket.type, BtpPacket.TYPE_MESSAGE, 'First message sent over BTP connection must be auth packet')\n    assert(authPacket.data.protocolData.length >= 2, 'Auth packet must have auth and auth_token subprotocols')\n    assert.strictEqual(authPacket.data.protocolData[0].protocolName, 'auth', 'First subprotocol must be auth')\n\n    const tokenProto = authPacket.data.protocolData.find(\n      (subProtocol) => subProtocol.protocolName === 'auth_token')\n    assert(tokenProto, 'auth_token subprotocol is required')\n    const wantToken = this._listenerSecret!\n    const gotToken = tokenProto!.data\n    if (gotToken.length !== wantToken.length\n      || !crypto.timingSafeEqual(gotToken, wantToken)) {\n      this._log.debug('received token \"%s\", but expected \"%s\"', gotToken.toString(), this._listener!.secret.toString())\n      throw new Error('invalid auth_token')\n    }\n  }\n}\n\n/**\n * Generate a new request id.\n */\nfunction _requestId (): Promise<number> {\n  return new Promise<number>((resolve, reject) => {\n    crypto.randomBytes(4, (err, buf) => {\n      if (err) return reject(err)\n      resolve(buf.readUInt32BE(0))\n    })\n  })\n}\n"]}