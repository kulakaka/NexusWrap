"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const oer_utils_1 = require("oer-utils");
const dateFormat = require("dateformat");
var Type;
(function (Type) {
    Type[Type["TYPE_RESPONSE"] = 1] = "TYPE_RESPONSE";
    Type[Type["TYPE_ERROR"] = 2] = "TYPE_ERROR";
    Type[Type["TYPE_MESSAGE"] = 6] = "TYPE_MESSAGE";
    Type[Type["TYPE_TRANSFER"] = 7] = "TYPE_TRANSFER";
})(Type = exports.Type || (exports.Type = {}));
exports.TYPE_RESPONSE = Type.TYPE_RESPONSE;
exports.TYPE_ERROR = Type.TYPE_ERROR;
exports.TYPE_MESSAGE = Type.TYPE_MESSAGE;
exports.TYPE_TRANSFER = Type.TYPE_TRANSFER;
exports.MIME_APPLICATION_OCTET_STREAM = 0;
exports.MIME_TEXT_PLAIN_UTF8 = 1;
exports.MIME_APPLICATION_JSON = 2;
function typeToString(type) {
    switch (type) {
        case Type.TYPE_RESPONSE: return 'TYPE_RESPONSE';
        case Type.TYPE_ERROR: return 'TYPE_ERROR';
        case Type.TYPE_MESSAGE: return 'TYPE_MESSAGE';
        case Type.TYPE_TRANSFER: return 'TYPE_TRANSFER';
        default: throw new Error('Unrecognized BTP packet type');
    }
}
exports.typeToString = typeToString;
const GENERALIZED_TIME_REGEX = /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2}\.[0-9]{3}Z)$/;
const protocolNameCache = {};
registerProtocolNames([
    'ilp',
    'auth',
    'auth_username',
    'auth_token',
    'channel',
    'channel_signature',
    'claim',
    'fund_channel',
    'info',
    'last_claim'
]);
function registerProtocolNames(names) {
    for (const protocolName of names) {
        protocolNameCache[protocolName] = Buffer.from(protocolName, 'ascii');
    }
}
exports.registerProtocolNames = registerProtocolNames;
function base64url(input) {
    return input.toString('base64')
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
}
exports.base64url = base64url;
function toGeneralizedTimeBuffer(date) {
    return Buffer.from(dateFormat(date, "UTC:yyyymmddHHMMss.l'Z'"));
}
function readGeneralizedTime(reader) {
    const generalizedTime = reader.readVarOctetString().toString();
    const date = generalizedTime.replace(GENERALIZED_TIME_REGEX, '$1-$2-$3T$4:$5:$6');
    return new Date(date);
}
function writeProtocolData(writer, protocolData) {
    if (!Array.isArray(protocolData)) {
        throw new Error('protocolData must be an array');
    }
    const lengthPrefix = protocolData.length;
    const lengthPrefixLengthPrefix = Math.max(1, Math.ceil((Math.log(protocolData.length + 1) / Math.log(2)) / 8));
    writer.writeUInt8(lengthPrefixLengthPrefix);
    writer.writeUInt(lengthPrefix, lengthPrefixLengthPrefix);
    for (const p of protocolData) {
        writer.writeVarOctetString(protocolNameCache[p.protocolName] ||
            Buffer.from(p.protocolName, 'ascii'));
        writer.writeUInt8(p.contentType);
        writer.writeVarOctetString(p.data);
    }
}
function readProtocolData(reader) {
    const lengthPrefixPrefix = reader.readUInt8Number();
    const lengthPrefix = reader.readUIntNumber(lengthPrefixPrefix);
    const protocolData = [];
    for (let i = 0; i < lengthPrefix; ++i) {
        const protocolName = reader.readVarOctetString().toString('ascii');
        const contentType = reader.readUInt8Number();
        const data = reader.readVarOctetString();
        protocolData.push({
            protocolName,
            contentType,
            data
        });
    }
    return protocolData;
}
function writeTransfer(writer, data) {
    writer.writeUInt64(data.amount);
    writeProtocolData(writer, data.protocolData);
}
function writeError(writer, data) {
    if (data.code.length !== 3) {
        throw new Error(`error code must be 3 characters, got: "${data.code}"`);
    }
    const codeBuffer = Buffer.from(data.code, 'ascii');
    const nameBuffer = Buffer.from(data.name, 'ascii');
    const triggeredAtBuffer = toGeneralizedTimeBuffer(data.triggeredAt);
    const dataBuffer = Buffer.from(data.data, 'utf8');
    writer.write(codeBuffer);
    writer.writeVarOctetString(nameBuffer);
    writer.writeVarOctetString(triggeredAtBuffer);
    writer.writeVarOctetString(dataBuffer);
    writeProtocolData(writer, data.protocolData);
}
function writeContents(writer, obj) {
    switch (obj.type) {
        case Type.TYPE_RESPONSE:
        case Type.TYPE_MESSAGE:
            writeProtocolData(writer, obj.data.protocolData);
            break;
        case Type.TYPE_TRANSFER:
            writeTransfer(writer, obj.data);
            break;
        case Type.TYPE_ERROR:
            writeError(writer, obj.data);
            break;
        default:
            throw new Error('Unrecognized type');
    }
}
function serialize(obj) {
    const contentsPredictor = new oer_utils_1.Predictor();
    writeContents(contentsPredictor, obj);
    const envelopeSize = 1 + 4 +
        oer_utils_1.Predictor.measureVarOctetString(contentsPredictor.length);
    const envelopeWriter = new oer_utils_1.Writer(envelopeSize);
    envelopeWriter.writeUInt8(obj.type);
    envelopeWriter.writeUInt32(obj.requestId);
    const contentsWriter = envelopeWriter.createVarOctetString(contentsPredictor.length);
    writeContents(contentsWriter, obj);
    return envelopeWriter.getBuffer();
}
exports.serialize = serialize;
function readTransfer(reader) {
    const amount = reader.readUInt64();
    const protocolData = readProtocolData(reader);
    return { amount, protocolData };
}
function readError(reader) {
    const code = reader.read(3).toString('ascii');
    const name = reader.readVarOctetString().toString('ascii');
    const triggeredAt = readGeneralizedTime(reader);
    const data = reader.readVarOctetString().toString('utf8');
    const protocolData = readProtocolData(reader);
    return { code, name, triggeredAt, data, protocolData };
}
function deserialize(buffer) {
    const envelopeReader = oer_utils_1.Reader.from(buffer);
    const type = envelopeReader.readUInt8Number();
    const requestId = envelopeReader.readUInt32Number();
    const dataBuff = envelopeReader.readVarOctetString();
    const reader = new oer_utils_1.Reader(dataBuff);
    let data;
    switch (type) {
        case Type.TYPE_RESPONSE:
        case Type.TYPE_MESSAGE:
            data = { protocolData: readProtocolData(reader) };
            break;
        case Type.TYPE_TRANSFER:
            data = readTransfer(reader);
            break;
        case Type.TYPE_ERROR:
            data = readError(reader);
            break;
        default:
            throw new Error('Unrecognized type');
    }
    return { type, requestId, data };
}
exports.deserialize = deserialize;
exports.serializeResponse = (requestId, protocolData) => {
    return serialize({
        type: Type.TYPE_RESPONSE,
        requestId,
        data: { protocolData }
    });
};
exports.serializeError = (error, requestId, protocolData) => {
    let dataFields;
    const { code, name, triggeredAt, data } = error;
    dataFields = { code, name, triggeredAt, data, protocolData };
    return serialize({
        type: Type.TYPE_ERROR,
        requestId,
        data: dataFields
    });
};
exports.serializeMessage = (requestId, protocolData) => {
    return serialize({
        type: Type.TYPE_MESSAGE,
        requestId,
        data: { protocolData }
    });
};
exports.serializeTransfer = (transfer, requestId, protocolData) => {
    const { amount } = transfer;
    return serialize({
        type: Type.TYPE_TRANSFER,
        requestId,
        data: {
            amount,
            protocolData
        }
    });
};
//# sourceMappingURL=index.js.map